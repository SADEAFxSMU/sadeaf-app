# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"columns and relationships of \"account\""
type account {
  "An object relationship"
  admin: admin
  "An object relationship"
  client: client
  cognito_id: String
  contact: String
  created_at: timestamp!
  email: String!
  id: Int!
  is_enabled: Boolean!
  "An array relationship"
  memberships(
    "distinct select on columns"
    distinct_on: [membership_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [membership_order_by!]
    "filter the rows returned"
    where: membership_bool_exp
  ): [membership!]!
  "An aggregated array relationship"
  memberships_aggregate(
    "distinct select on columns"
    distinct_on: [membership_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [membership_order_by!]
    "filter the rows returned"
    where: membership_bool_exp
  ): membership_aggregate!
  name: String
  "An object relationship"
  notification_setting: notification_setting
  profile_pic_url: String
  role: String!
  "An object relationship"
  service_requestor: service_requestor
  updated_at: timestamp!
  "An object relationship"
  volunteer: volunteer
}

"aggregated selection of \"account\""
type account_aggregate {
  aggregate: account_aggregate_fields
  nodes: [account!]!
}

"aggregate fields of \"account\""
type account_aggregate_fields {
  avg: account_avg_fields
  count(columns: [account_select_column!], distinct: Boolean): Int
  max: account_max_fields
  min: account_min_fields
  stddev: account_stddev_fields
  stddev_pop: account_stddev_pop_fields
  stddev_samp: account_stddev_samp_fields
  sum: account_sum_fields
  var_pop: account_var_pop_fields
  var_samp: account_var_samp_fields
  variance: account_variance_fields
}

"aggregate avg on columns"
type account_avg_fields {
  id: Float
}

"aggregate max on columns"
type account_max_fields {
  cognito_id: String
  contact: String
  created_at: timestamp
  email: String
  id: Int
  name: String
  profile_pic_url: String
  role: String
  updated_at: timestamp
}

"aggregate min on columns"
type account_min_fields {
  cognito_id: String
  contact: String
  created_at: timestamp
  email: String
  id: Int
  name: String
  profile_pic_url: String
  role: String
  updated_at: timestamp
}

"response of any mutation on the table \"account\""
type account_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [account!]!
}

"aggregate stddev on columns"
type account_stddev_fields {
  id: Float
}

"aggregate stddev_pop on columns"
type account_stddev_pop_fields {
  id: Float
}

"aggregate stddev_samp on columns"
type account_stddev_samp_fields {
  id: Float
}

"aggregate sum on columns"
type account_sum_fields {
  id: Int
}

"aggregate var_pop on columns"
type account_var_pop_fields {
  id: Float
}

"aggregate var_samp on columns"
type account_var_samp_fields {
  id: Float
}

"aggregate variance on columns"
type account_variance_fields {
  id: Float
}

"columns and relationships of \"admin\""
type admin {
  "An object relationship"
  account: account!
  account_id: Int!
  id: Int!
}

"aggregated selection of \"admin\""
type admin_aggregate {
  aggregate: admin_aggregate_fields
  nodes: [admin!]!
}

"aggregate fields of \"admin\""
type admin_aggregate_fields {
  avg: admin_avg_fields
  count(columns: [admin_select_column!], distinct: Boolean): Int
  max: admin_max_fields
  min: admin_min_fields
  stddev: admin_stddev_fields
  stddev_pop: admin_stddev_pop_fields
  stddev_samp: admin_stddev_samp_fields
  sum: admin_sum_fields
  var_pop: admin_var_pop_fields
  var_samp: admin_var_samp_fields
  variance: admin_variance_fields
}

"aggregate avg on columns"
type admin_avg_fields {
  account_id: Float
  id: Float
}

"aggregate max on columns"
type admin_max_fields {
  account_id: Int
  id: Int
}

"aggregate min on columns"
type admin_min_fields {
  account_id: Int
  id: Int
}

"response of any mutation on the table \"admin\""
type admin_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [admin!]!
}

"aggregate stddev on columns"
type admin_stddev_fields {
  account_id: Float
  id: Float
}

"aggregate stddev_pop on columns"
type admin_stddev_pop_fields {
  account_id: Float
  id: Float
}

"aggregate stddev_samp on columns"
type admin_stddev_samp_fields {
  account_id: Float
  id: Float
}

"aggregate sum on columns"
type admin_sum_fields {
  account_id: Int
  id: Int
}

"aggregate var_pop on columns"
type admin_var_pop_fields {
  account_id: Float
  id: Float
}

"aggregate var_samp on columns"
type admin_var_samp_fields {
  account_id: Float
  id: Float
}

"aggregate variance on columns"
type admin_variance_fields {
  account_id: Float
  id: Float
}

"columns and relationships of \"assignment\""
type assignment {
  address_line_one: String
  address_line_two: String
  "An object relationship"
  attendance: attendance
  end_dt: timestamp!
  "An object relationship"
  event: event!
  event_id: Int!
  honorarium_amount: float8
  id: Int!
  latitude: float8
  longitude: float8
  postal: String
  room_number: String
  start_dt: timestamp!
  status: String!
  "An object relationship"
  volunteer: volunteer
  "An array relationship"
  volunteer_assignment_opt_ins(
    "distinct select on columns"
    distinct_on: [volunteer_assignment_opt_in_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [volunteer_assignment_opt_in_order_by!]
    "filter the rows returned"
    where: volunteer_assignment_opt_in_bool_exp
  ): [volunteer_assignment_opt_in!]!
  "An aggregated array relationship"
  volunteer_assignment_opt_ins_aggregate(
    "distinct select on columns"
    distinct_on: [volunteer_assignment_opt_in_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [volunteer_assignment_opt_in_order_by!]
    "filter the rows returned"
    where: volunteer_assignment_opt_in_bool_exp
  ): volunteer_assignment_opt_in_aggregate!
  volunteer_id: Int
}

"aggregated selection of \"assignment\""
type assignment_aggregate {
  aggregate: assignment_aggregate_fields
  nodes: [assignment!]!
}

"aggregate fields of \"assignment\""
type assignment_aggregate_fields {
  avg: assignment_avg_fields
  count(columns: [assignment_select_column!], distinct: Boolean): Int
  max: assignment_max_fields
  min: assignment_min_fields
  stddev: assignment_stddev_fields
  stddev_pop: assignment_stddev_pop_fields
  stddev_samp: assignment_stddev_samp_fields
  sum: assignment_sum_fields
  var_pop: assignment_var_pop_fields
  var_samp: assignment_var_samp_fields
  variance: assignment_variance_fields
}

"aggregate avg on columns"
type assignment_avg_fields {
  event_id: Float
  honorarium_amount: Float
  id: Float
  latitude: Float
  longitude: Float
  volunteer_id: Float
}

"aggregate max on columns"
type assignment_max_fields {
  address_line_one: String
  address_line_two: String
  end_dt: timestamp
  event_id: Int
  honorarium_amount: float8
  id: Int
  latitude: float8
  longitude: float8
  postal: String
  room_number: String
  start_dt: timestamp
  status: String
  volunteer_id: Int
}

"aggregate min on columns"
type assignment_min_fields {
  address_line_one: String
  address_line_two: String
  end_dt: timestamp
  event_id: Int
  honorarium_amount: float8
  id: Int
  latitude: float8
  longitude: float8
  postal: String
  room_number: String
  start_dt: timestamp
  status: String
  volunteer_id: Int
}

"response of any mutation on the table \"assignment\""
type assignment_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [assignment!]!
}

"aggregate stddev on columns"
type assignment_stddev_fields {
  event_id: Float
  honorarium_amount: Float
  id: Float
  latitude: Float
  longitude: Float
  volunteer_id: Float
}

"aggregate stddev_pop on columns"
type assignment_stddev_pop_fields {
  event_id: Float
  honorarium_amount: Float
  id: Float
  latitude: Float
  longitude: Float
  volunteer_id: Float
}

"aggregate stddev_samp on columns"
type assignment_stddev_samp_fields {
  event_id: Float
  honorarium_amount: Float
  id: Float
  latitude: Float
  longitude: Float
  volunteer_id: Float
}

"aggregate sum on columns"
type assignment_sum_fields {
  event_id: Int
  honorarium_amount: float8
  id: Int
  latitude: float8
  longitude: float8
  volunteer_id: Int
}

"aggregate var_pop on columns"
type assignment_var_pop_fields {
  event_id: Float
  honorarium_amount: Float
  id: Float
  latitude: Float
  longitude: Float
  volunteer_id: Float
}

"aggregate var_samp on columns"
type assignment_var_samp_fields {
  event_id: Float
  honorarium_amount: Float
  id: Float
  latitude: Float
  longitude: Float
  volunteer_id: Float
}

"aggregate variance on columns"
type assignment_variance_fields {
  event_id: Float
  honorarium_amount: Float
  id: Float
  latitude: Float
  longitude: Float
  volunteer_id: Float
}

"columns and relationships of \"attendance\""
type attendance {
  "An object relationship"
  assignment: assignment!
  assignment_id: Int!
  attended: Boolean!
  dispute_comment: String
  has_dispute: Boolean!
  id: Int!
}

"aggregated selection of \"attendance\""
type attendance_aggregate {
  aggregate: attendance_aggregate_fields
  nodes: [attendance!]!
}

"aggregate fields of \"attendance\""
type attendance_aggregate_fields {
  avg: attendance_avg_fields
  count(columns: [attendance_select_column!], distinct: Boolean): Int
  max: attendance_max_fields
  min: attendance_min_fields
  stddev: attendance_stddev_fields
  stddev_pop: attendance_stddev_pop_fields
  stddev_samp: attendance_stddev_samp_fields
  sum: attendance_sum_fields
  var_pop: attendance_var_pop_fields
  var_samp: attendance_var_samp_fields
  variance: attendance_variance_fields
}

"aggregate avg on columns"
type attendance_avg_fields {
  assignment_id: Float
  id: Float
}

"aggregate max on columns"
type attendance_max_fields {
  assignment_id: Int
  dispute_comment: String
  id: Int
}

"aggregate min on columns"
type attendance_min_fields {
  assignment_id: Int
  dispute_comment: String
  id: Int
}

"response of any mutation on the table \"attendance\""
type attendance_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [attendance!]!
}

"aggregate stddev on columns"
type attendance_stddev_fields {
  assignment_id: Float
  id: Float
}

"aggregate stddev_pop on columns"
type attendance_stddev_pop_fields {
  assignment_id: Float
  id: Float
}

"aggregate stddev_samp on columns"
type attendance_stddev_samp_fields {
  assignment_id: Float
  id: Float
}

"aggregate sum on columns"
type attendance_sum_fields {
  assignment_id: Int
  id: Int
}

"aggregate var_pop on columns"
type attendance_var_pop_fields {
  assignment_id: Float
  id: Float
}

"aggregate var_samp on columns"
type attendance_var_samp_fields {
  assignment_id: Float
  id: Float
}

"aggregate variance on columns"
type attendance_variance_fields {
  assignment_id: Float
  id: Float
}

"columns and relationships of \"blacklist\""
type blacklist {
  "An object relationship"
  client: client!
  client_account_id: Int!
  id: Int!
  "An object relationship"
  volunteer: volunteer!
  volunteer_account_id: Int!
}

"aggregated selection of \"blacklist\""
type blacklist_aggregate {
  aggregate: blacklist_aggregate_fields
  nodes: [blacklist!]!
}

"aggregate fields of \"blacklist\""
type blacklist_aggregate_fields {
  avg: blacklist_avg_fields
  count(columns: [blacklist_select_column!], distinct: Boolean): Int
  max: blacklist_max_fields
  min: blacklist_min_fields
  stddev: blacklist_stddev_fields
  stddev_pop: blacklist_stddev_pop_fields
  stddev_samp: blacklist_stddev_samp_fields
  sum: blacklist_sum_fields
  var_pop: blacklist_var_pop_fields
  var_samp: blacklist_var_samp_fields
  variance: blacklist_variance_fields
}

"aggregate avg on columns"
type blacklist_avg_fields {
  client_account_id: Float
  id: Float
  volunteer_account_id: Float
}

"aggregate max on columns"
type blacklist_max_fields {
  client_account_id: Int
  id: Int
  volunteer_account_id: Int
}

"aggregate min on columns"
type blacklist_min_fields {
  client_account_id: Int
  id: Int
  volunteer_account_id: Int
}

"response of any mutation on the table \"blacklist\""
type blacklist_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [blacklist!]!
}

"aggregate stddev on columns"
type blacklist_stddev_fields {
  client_account_id: Float
  id: Float
  volunteer_account_id: Float
}

"aggregate stddev_pop on columns"
type blacklist_stddev_pop_fields {
  client_account_id: Float
  id: Float
  volunteer_account_id: Float
}

"aggregate stddev_samp on columns"
type blacklist_stddev_samp_fields {
  client_account_id: Float
  id: Float
  volunteer_account_id: Float
}

"aggregate sum on columns"
type blacklist_sum_fields {
  client_account_id: Int
  id: Int
  volunteer_account_id: Int
}

"aggregate var_pop on columns"
type blacklist_var_pop_fields {
  client_account_id: Float
  id: Float
  volunteer_account_id: Float
}

"aggregate var_samp on columns"
type blacklist_var_samp_fields {
  client_account_id: Float
  id: Float
  volunteer_account_id: Float
}

"aggregate variance on columns"
type blacklist_variance_fields {
  client_account_id: Float
  id: Float
  volunteer_account_id: Float
}

"columns and relationships of \"client\""
type client {
  "An object relationship"
  account: account!
  account_id: Int!
  additional_notes: String
  "An array relationship"
  blacklists(
    "distinct select on columns"
    distinct_on: [blacklist_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [blacklist_order_by!]
    "filter the rows returned"
    where: blacklist_bool_exp
  ): [blacklist!]!
  "An aggregated array relationship"
  blacklists_aggregate(
    "distinct select on columns"
    distinct_on: [blacklist_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [blacklist_order_by!]
    "filter the rows returned"
    where: blacklist_bool_exp
  ): blacklist_aggregate!
  designation: String
  "An array relationship"
  events(
    "distinct select on columns"
    distinct_on: [event_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [event_order_by!]
    "filter the rows returned"
    where: event_bool_exp
  ): [event!]!
  "An aggregated array relationship"
  events_aggregate(
    "distinct select on columns"
    distinct_on: [event_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [event_order_by!]
    "filter the rows returned"
    where: event_bool_exp
  ): event_aggregate!
  id: Int!
  organisation: String
  preferred_comm_mode: String!
  "An object relationship"
  quotation: quotation
  quotation_id: Int
  "An object relationship"
  service_requestor: service_requestor
  service_requestor_id: Int
}

"aggregated selection of \"client\""
type client_aggregate {
  aggregate: client_aggregate_fields
  nodes: [client!]!
}

"aggregate fields of \"client\""
type client_aggregate_fields {
  avg: client_avg_fields
  count(columns: [client_select_column!], distinct: Boolean): Int
  max: client_max_fields
  min: client_min_fields
  stddev: client_stddev_fields
  stddev_pop: client_stddev_pop_fields
  stddev_samp: client_stddev_samp_fields
  sum: client_sum_fields
  var_pop: client_var_pop_fields
  var_samp: client_var_samp_fields
  variance: client_variance_fields
}

"aggregate avg on columns"
type client_avg_fields {
  account_id: Float
  id: Float
  quotation_id: Float
  service_requestor_id: Float
}

"aggregate max on columns"
type client_max_fields {
  account_id: Int
  additional_notes: String
  designation: String
  id: Int
  organisation: String
  preferred_comm_mode: String
  quotation_id: Int
  service_requestor_id: Int
}

"aggregate min on columns"
type client_min_fields {
  account_id: Int
  additional_notes: String
  designation: String
  id: Int
  organisation: String
  preferred_comm_mode: String
  quotation_id: Int
  service_requestor_id: Int
}

"response of any mutation on the table \"client\""
type client_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [client!]!
}

"aggregate stddev on columns"
type client_stddev_fields {
  account_id: Float
  id: Float
  quotation_id: Float
  service_requestor_id: Float
}

"aggregate stddev_pop on columns"
type client_stddev_pop_fields {
  account_id: Float
  id: Float
  quotation_id: Float
  service_requestor_id: Float
}

"aggregate stddev_samp on columns"
type client_stddev_samp_fields {
  account_id: Float
  id: Float
  quotation_id: Float
  service_requestor_id: Float
}

"aggregate sum on columns"
type client_sum_fields {
  account_id: Int
  id: Int
  quotation_id: Int
  service_requestor_id: Int
}

"aggregate var_pop on columns"
type client_var_pop_fields {
  account_id: Float
  id: Float
  quotation_id: Float
  service_requestor_id: Float
}

"aggregate var_samp on columns"
type client_var_samp_fields {
  account_id: Float
  id: Float
  quotation_id: Float
  service_requestor_id: Float
}

"aggregate variance on columns"
type client_variance_fields {
  account_id: Float
  id: Float
  quotation_id: Float
  service_requestor_id: Float
}

"columns and relationships of \"email_information\""
type email_information {
  id: Int!
  "An object relationship"
  notification_setting: notification_setting!
  notification_setting_id: Int!
}

"aggregated selection of \"email_information\""
type email_information_aggregate {
  aggregate: email_information_aggregate_fields
  nodes: [email_information!]!
}

"aggregate fields of \"email_information\""
type email_information_aggregate_fields {
  avg: email_information_avg_fields
  count(columns: [email_information_select_column!], distinct: Boolean): Int
  max: email_information_max_fields
  min: email_information_min_fields
  stddev: email_information_stddev_fields
  stddev_pop: email_information_stddev_pop_fields
  stddev_samp: email_information_stddev_samp_fields
  sum: email_information_sum_fields
  var_pop: email_information_var_pop_fields
  var_samp: email_information_var_samp_fields
  variance: email_information_variance_fields
}

"aggregate avg on columns"
type email_information_avg_fields {
  id: Float
  notification_setting_id: Float
}

"aggregate max on columns"
type email_information_max_fields {
  id: Int
  notification_setting_id: Int
}

"aggregate min on columns"
type email_information_min_fields {
  id: Int
  notification_setting_id: Int
}

"response of any mutation on the table \"email_information\""
type email_information_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [email_information!]!
}

"aggregate stddev on columns"
type email_information_stddev_fields {
  id: Float
  notification_setting_id: Float
}

"aggregate stddev_pop on columns"
type email_information_stddev_pop_fields {
  id: Float
  notification_setting_id: Float
}

"aggregate stddev_samp on columns"
type email_information_stddev_samp_fields {
  id: Float
  notification_setting_id: Float
}

"aggregate sum on columns"
type email_information_sum_fields {
  id: Int
  notification_setting_id: Int
}

"aggregate var_pop on columns"
type email_information_var_pop_fields {
  id: Float
  notification_setting_id: Float
}

"aggregate var_samp on columns"
type email_information_var_samp_fields {
  id: Float
  notification_setting_id: Float
}

"aggregate variance on columns"
type email_information_variance_fields {
  id: Float
  notification_setting_id: Float
}

"columns and relationships of \"event\""
type event {
  "An array relationship"
  assignments(
    "distinct select on columns"
    distinct_on: [assignment_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assignment_order_by!]
    "filter the rows returned"
    where: assignment_bool_exp
  ): [assignment!]!
  "An aggregated array relationship"
  assignments_aggregate(
    "distinct select on columns"
    distinct_on: [assignment_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assignment_order_by!]
    "filter the rows returned"
    where: assignment_bool_exp
  ): assignment_aggregate!
  "An object relationship"
  client: client!
  client_id: Int!
  created_at: timestamp!
  description: String
  "An array relationship"
  feedbacks(
    "distinct select on columns"
    distinct_on: [feedback_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [feedback_order_by!]
    "filter the rows returned"
    where: feedback_bool_exp
  ): [feedback!]!
  "An aggregated array relationship"
  feedbacks_aggregate(
    "distinct select on columns"
    distinct_on: [feedback_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [feedback_order_by!]
    "filter the rows returned"
    where: feedback_bool_exp
  ): feedback_aggregate!
  id: Int!
  "An object relationship"
  interpretation_detail: interpretation_details
  interpreter_required: Boolean
  "An object relationship"
  invoice: invoice
  name: String!
  notetaker_required: Boolean!
  purpose: String
  "A computed field, executes function \"get_uncompleted_status\""
  uncompleted_status: Boolean
  updated_at: timestamp!
}

"aggregated selection of \"event\""
type event_aggregate {
  aggregate: event_aggregate_fields
  nodes: [event!]!
}

"aggregate fields of \"event\""
type event_aggregate_fields {
  avg: event_avg_fields
  count(columns: [event_select_column!], distinct: Boolean): Int
  max: event_max_fields
  min: event_min_fields
  stddev: event_stddev_fields
  stddev_pop: event_stddev_pop_fields
  stddev_samp: event_stddev_samp_fields
  sum: event_sum_fields
  var_pop: event_var_pop_fields
  var_samp: event_var_samp_fields
  variance: event_variance_fields
}

"aggregate avg on columns"
type event_avg_fields {
  client_id: Float
  id: Float
}

"aggregate max on columns"
type event_max_fields {
  client_id: Int
  created_at: timestamp
  description: String
  id: Int
  name: String
  purpose: String
  updated_at: timestamp
}

"aggregate min on columns"
type event_min_fields {
  client_id: Int
  created_at: timestamp
  description: String
  id: Int
  name: String
  purpose: String
  updated_at: timestamp
}

"response of any mutation on the table \"event\""
type event_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [event!]!
}

"aggregate stddev on columns"
type event_stddev_fields {
  client_id: Float
  id: Float
}

"aggregate stddev_pop on columns"
type event_stddev_pop_fields {
  client_id: Float
  id: Float
}

"aggregate stddev_samp on columns"
type event_stddev_samp_fields {
  client_id: Float
  id: Float
}

"aggregate sum on columns"
type event_sum_fields {
  client_id: Int
  id: Int
}

"aggregate var_pop on columns"
type event_var_pop_fields {
  client_id: Float
  id: Float
}

"aggregate var_samp on columns"
type event_var_samp_fields {
  client_id: Float
  id: Float
}

"aggregate variance on columns"
type event_variance_fields {
  client_id: Float
  id: Float
}

"columns and relationships of \"feedback\""
type feedback {
  confidentiality_privacy_preference: privacy_enum
  created_at: timestamp!
  "An object relationship"
  event: event!
  event_id: Int!
  feedback_given: Int!
  general_feedback: String
  "Check feedback id value before inserting / updating feedback manually. It takes into account previous feedback's that have been added and increments it by 1."
  id: Int!
  live_comments: String
  live_information_understanding: rating_enum
  live_interaction: rating_enum
  notetaker_conduct: rating_enum
  notetaker_punctual: rating_enum
  post_session_comments: String
  post_session_understanding: rating_enum
  training_privacy_preference: privacy_enum
  updated_at: timestamp!
  "An object relationship"
  volunteer: volunteer!
  volunteer_id: Int!
}

"aggregated selection of \"feedback\""
type feedback_aggregate {
  aggregate: feedback_aggregate_fields
  nodes: [feedback!]!
}

"aggregate fields of \"feedback\""
type feedback_aggregate_fields {
  avg: feedback_avg_fields
  count(columns: [feedback_select_column!], distinct: Boolean): Int
  max: feedback_max_fields
  min: feedback_min_fields
  stddev: feedback_stddev_fields
  stddev_pop: feedback_stddev_pop_fields
  stddev_samp: feedback_stddev_samp_fields
  sum: feedback_sum_fields
  var_pop: feedback_var_pop_fields
  var_samp: feedback_var_samp_fields
  variance: feedback_variance_fields
}

"aggregate avg on columns"
type feedback_avg_fields {
  event_id: Float
  feedback_given: Float
  id: Float
  volunteer_id: Float
}

"aggregate max on columns"
type feedback_max_fields {
  created_at: timestamp
  event_id: Int
  feedback_given: Int
  general_feedback: String
  id: Int
  live_comments: String
  post_session_comments: String
  updated_at: timestamp
  volunteer_id: Int
}

"aggregate min on columns"
type feedback_min_fields {
  created_at: timestamp
  event_id: Int
  feedback_given: Int
  general_feedback: String
  id: Int
  live_comments: String
  post_session_comments: String
  updated_at: timestamp
  volunteer_id: Int
}

"response of any mutation on the table \"feedback\""
type feedback_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [feedback!]!
}

"aggregate stddev on columns"
type feedback_stddev_fields {
  event_id: Float
  feedback_given: Float
  id: Float
  volunteer_id: Float
}

"aggregate stddev_pop on columns"
type feedback_stddev_pop_fields {
  event_id: Float
  feedback_given: Float
  id: Float
  volunteer_id: Float
}

"aggregate stddev_samp on columns"
type feedback_stddev_samp_fields {
  event_id: Float
  feedback_given: Float
  id: Float
  volunteer_id: Float
}

"aggregate sum on columns"
type feedback_sum_fields {
  event_id: Int
  feedback_given: Int
  id: Int
  volunteer_id: Int
}

"aggregate var_pop on columns"
type feedback_var_pop_fields {
  event_id: Float
  feedback_given: Float
  id: Float
  volunteer_id: Float
}

"aggregate var_samp on columns"
type feedback_var_samp_fields {
  event_id: Float
  feedback_given: Float
  id: Float
  volunteer_id: Float
}

"aggregate variance on columns"
type feedback_variance_fields {
  event_id: Float
  feedback_given: Float
  id: Float
  volunteer_id: Float
}

"columns and relationships of \"interpretation_details\""
type interpretation_details {
  allow_trainee_interpreters: Boolean!
  "An object relationship"
  event: event
  event_id: Int
  filming_interpreters: Boolean!
  id: Int!
  number_of_deaf: Int!
  number_of_hearing: Int!
  sign_system: String!
}

"aggregated selection of \"interpretation_details\""
type interpretation_details_aggregate {
  aggregate: interpretation_details_aggregate_fields
  nodes: [interpretation_details!]!
}

"aggregate fields of \"interpretation_details\""
type interpretation_details_aggregate_fields {
  avg: interpretation_details_avg_fields
  count(columns: [interpretation_details_select_column!], distinct: Boolean): Int
  max: interpretation_details_max_fields
  min: interpretation_details_min_fields
  stddev: interpretation_details_stddev_fields
  stddev_pop: interpretation_details_stddev_pop_fields
  stddev_samp: interpretation_details_stddev_samp_fields
  sum: interpretation_details_sum_fields
  var_pop: interpretation_details_var_pop_fields
  var_samp: interpretation_details_var_samp_fields
  variance: interpretation_details_variance_fields
}

"aggregate avg on columns"
type interpretation_details_avg_fields {
  event_id: Float
  id: Float
  number_of_deaf: Float
  number_of_hearing: Float
}

"aggregate max on columns"
type interpretation_details_max_fields {
  event_id: Int
  id: Int
  number_of_deaf: Int
  number_of_hearing: Int
  sign_system: String
}

"aggregate min on columns"
type interpretation_details_min_fields {
  event_id: Int
  id: Int
  number_of_deaf: Int
  number_of_hearing: Int
  sign_system: String
}

"response of any mutation on the table \"interpretation_details\""
type interpretation_details_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [interpretation_details!]!
}

"aggregate stddev on columns"
type interpretation_details_stddev_fields {
  event_id: Float
  id: Float
  number_of_deaf: Float
  number_of_hearing: Float
}

"aggregate stddev_pop on columns"
type interpretation_details_stddev_pop_fields {
  event_id: Float
  id: Float
  number_of_deaf: Float
  number_of_hearing: Float
}

"aggregate stddev_samp on columns"
type interpretation_details_stddev_samp_fields {
  event_id: Float
  id: Float
  number_of_deaf: Float
  number_of_hearing: Float
}

"aggregate sum on columns"
type interpretation_details_sum_fields {
  event_id: Int
  id: Int
  number_of_deaf: Int
  number_of_hearing: Int
}

"aggregate var_pop on columns"
type interpretation_details_var_pop_fields {
  event_id: Float
  id: Float
  number_of_deaf: Float
  number_of_hearing: Float
}

"aggregate var_samp on columns"
type interpretation_details_var_samp_fields {
  event_id: Float
  id: Float
  number_of_deaf: Float
  number_of_hearing: Float
}

"aggregate variance on columns"
type interpretation_details_variance_fields {
  event_id: Float
  id: Float
  number_of_deaf: Float
  number_of_hearing: Float
}

"columns and relationships of \"invoice\""
type invoice {
  amount: numeric!
  created_at: timestamp!
  "An object relationship"
  event: event
  event_id: Int
  id: Int!
  name: String!
  updated_at: timestamp!
}

"aggregated selection of \"invoice\""
type invoice_aggregate {
  aggregate: invoice_aggregate_fields
  nodes: [invoice!]!
}

"aggregate fields of \"invoice\""
type invoice_aggregate_fields {
  avg: invoice_avg_fields
  count(columns: [invoice_select_column!], distinct: Boolean): Int
  max: invoice_max_fields
  min: invoice_min_fields
  stddev: invoice_stddev_fields
  stddev_pop: invoice_stddev_pop_fields
  stddev_samp: invoice_stddev_samp_fields
  sum: invoice_sum_fields
  var_pop: invoice_var_pop_fields
  var_samp: invoice_var_samp_fields
  variance: invoice_variance_fields
}

"aggregate avg on columns"
type invoice_avg_fields {
  amount: Float
  event_id: Float
  id: Float
}

"aggregate max on columns"
type invoice_max_fields {
  amount: numeric
  created_at: timestamp
  event_id: Int
  id: Int
  name: String
  updated_at: timestamp
}

"aggregate min on columns"
type invoice_min_fields {
  amount: numeric
  created_at: timestamp
  event_id: Int
  id: Int
  name: String
  updated_at: timestamp
}

"response of any mutation on the table \"invoice\""
type invoice_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [invoice!]!
}

"aggregate stddev on columns"
type invoice_stddev_fields {
  amount: Float
  event_id: Float
  id: Float
}

"aggregate stddev_pop on columns"
type invoice_stddev_pop_fields {
  amount: Float
  event_id: Float
  id: Float
}

"aggregate stddev_samp on columns"
type invoice_stddev_samp_fields {
  amount: Float
  event_id: Float
  id: Float
}

"aggregate sum on columns"
type invoice_sum_fields {
  amount: numeric
  event_id: Int
  id: Int
}

"aggregate var_pop on columns"
type invoice_var_pop_fields {
  amount: Float
  event_id: Float
  id: Float
}

"aggregate var_samp on columns"
type invoice_var_samp_fields {
  amount: Float
  event_id: Float
  id: Float
}

"aggregate variance on columns"
type invoice_variance_fields {
  amount: Float
  event_id: Float
  id: Float
}

"columns and relationships of \"membership\""
type membership {
  "An object relationship"
  account: account!
  account_id: Int!
  created_at: timestamp!
  free_sessions_remaining: numeric!
  id: Int!
  "An array relationship"
  membership_renewals(
    "distinct select on columns"
    distinct_on: [membership_renewals_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [membership_renewals_order_by!]
    "filter the rows returned"
    where: membership_renewals_bool_exp
  ): [membership_renewals!]!
  "An aggregated array relationship"
  membership_renewals_aggregate(
    "distinct select on columns"
    distinct_on: [membership_renewals_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [membership_renewals_order_by!]
    "filter the rows returned"
    where: membership_renewals_bool_exp
  ): membership_renewals_aggregate!
  "An object relationship"
  membership_type: membership_type!
  membership_type_id: Int!
  "An array relationship"
  service_requestors(
    "distinct select on columns"
    distinct_on: [service_requestor_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [service_requestor_order_by!]
    "filter the rows returned"
    where: service_requestor_bool_exp
  ): [service_requestor!]!
  "An aggregated array relationship"
  service_requestors_aggregate(
    "distinct select on columns"
    distinct_on: [service_requestor_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [service_requestor_order_by!]
    "filter the rows returned"
    where: service_requestor_bool_exp
  ): service_requestor_aggregate!
  status: String!
  updated_at: timestamp!
}

"aggregated selection of \"membership\""
type membership_aggregate {
  aggregate: membership_aggregate_fields
  nodes: [membership!]!
}

"aggregate fields of \"membership\""
type membership_aggregate_fields {
  avg: membership_avg_fields
  count(columns: [membership_select_column!], distinct: Boolean): Int
  max: membership_max_fields
  min: membership_min_fields
  stddev: membership_stddev_fields
  stddev_pop: membership_stddev_pop_fields
  stddev_samp: membership_stddev_samp_fields
  sum: membership_sum_fields
  var_pop: membership_var_pop_fields
  var_samp: membership_var_samp_fields
  variance: membership_variance_fields
}

"aggregate avg on columns"
type membership_avg_fields {
  account_id: Float
  free_sessions_remaining: Float
  id: Float
  membership_type_id: Float
}

"aggregate max on columns"
type membership_max_fields {
  account_id: Int
  created_at: timestamp
  free_sessions_remaining: numeric
  id: Int
  membership_type_id: Int
  status: String
  updated_at: timestamp
}

"aggregate min on columns"
type membership_min_fields {
  account_id: Int
  created_at: timestamp
  free_sessions_remaining: numeric
  id: Int
  membership_type_id: Int
  status: String
  updated_at: timestamp
}

"response of any mutation on the table \"membership\""
type membership_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [membership!]!
}

"columns and relationships of \"membership_renewals\""
type membership_renewals {
  created_at: timestamp!
  id: Int!
  "An object relationship"
  membership: membership!
  membership_id: Int!
}

"aggregated selection of \"membership_renewals\""
type membership_renewals_aggregate {
  aggregate: membership_renewals_aggregate_fields
  nodes: [membership_renewals!]!
}

"aggregate fields of \"membership_renewals\""
type membership_renewals_aggregate_fields {
  avg: membership_renewals_avg_fields
  count(columns: [membership_renewals_select_column!], distinct: Boolean): Int
  max: membership_renewals_max_fields
  min: membership_renewals_min_fields
  stddev: membership_renewals_stddev_fields
  stddev_pop: membership_renewals_stddev_pop_fields
  stddev_samp: membership_renewals_stddev_samp_fields
  sum: membership_renewals_sum_fields
  var_pop: membership_renewals_var_pop_fields
  var_samp: membership_renewals_var_samp_fields
  variance: membership_renewals_variance_fields
}

"aggregate avg on columns"
type membership_renewals_avg_fields {
  id: Float
  membership_id: Float
}

"aggregate max on columns"
type membership_renewals_max_fields {
  created_at: timestamp
  id: Int
  membership_id: Int
}

"aggregate min on columns"
type membership_renewals_min_fields {
  created_at: timestamp
  id: Int
  membership_id: Int
}

"response of any mutation on the table \"membership_renewals\""
type membership_renewals_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [membership_renewals!]!
}

"aggregate stddev on columns"
type membership_renewals_stddev_fields {
  id: Float
  membership_id: Float
}

"aggregate stddev_pop on columns"
type membership_renewals_stddev_pop_fields {
  id: Float
  membership_id: Float
}

"aggregate stddev_samp on columns"
type membership_renewals_stddev_samp_fields {
  id: Float
  membership_id: Float
}

"aggregate sum on columns"
type membership_renewals_sum_fields {
  id: Int
  membership_id: Int
}

"aggregate var_pop on columns"
type membership_renewals_var_pop_fields {
  id: Float
  membership_id: Float
}

"aggregate var_samp on columns"
type membership_renewals_var_samp_fields {
  id: Float
  membership_id: Float
}

"aggregate variance on columns"
type membership_renewals_variance_fields {
  id: Float
  membership_id: Float
}

"aggregate stddev on columns"
type membership_stddev_fields {
  account_id: Float
  free_sessions_remaining: Float
  id: Float
  membership_type_id: Float
}

"aggregate stddev_pop on columns"
type membership_stddev_pop_fields {
  account_id: Float
  free_sessions_remaining: Float
  id: Float
  membership_type_id: Float
}

"aggregate stddev_samp on columns"
type membership_stddev_samp_fields {
  account_id: Float
  free_sessions_remaining: Float
  id: Float
  membership_type_id: Float
}

"aggregate sum on columns"
type membership_sum_fields {
  account_id: Int
  free_sessions_remaining: numeric
  id: Int
  membership_type_id: Int
}

"columns and relationships of \"membership_type\""
type membership_type {
  cost: numeric!
  description: String
  duration_in_days: Int!
  id: Int!
  "An array relationship"
  memberships(
    "distinct select on columns"
    distinct_on: [membership_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [membership_order_by!]
    "filter the rows returned"
    where: membership_bool_exp
  ): [membership!]!
  "An aggregated array relationship"
  memberships_aggregate(
    "distinct select on columns"
    distinct_on: [membership_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [membership_order_by!]
    "filter the rows returned"
    where: membership_bool_exp
  ): membership_aggregate!
  name: String!
}

"aggregated selection of \"membership_type\""
type membership_type_aggregate {
  aggregate: membership_type_aggregate_fields
  nodes: [membership_type!]!
}

"aggregate fields of \"membership_type\""
type membership_type_aggregate_fields {
  avg: membership_type_avg_fields
  count(columns: [membership_type_select_column!], distinct: Boolean): Int
  max: membership_type_max_fields
  min: membership_type_min_fields
  stddev: membership_type_stddev_fields
  stddev_pop: membership_type_stddev_pop_fields
  stddev_samp: membership_type_stddev_samp_fields
  sum: membership_type_sum_fields
  var_pop: membership_type_var_pop_fields
  var_samp: membership_type_var_samp_fields
  variance: membership_type_variance_fields
}

"aggregate avg on columns"
type membership_type_avg_fields {
  cost: Float
  duration_in_days: Float
  id: Float
}

"aggregate max on columns"
type membership_type_max_fields {
  cost: numeric
  description: String
  duration_in_days: Int
  id: Int
  name: String
}

"aggregate min on columns"
type membership_type_min_fields {
  cost: numeric
  description: String
  duration_in_days: Int
  id: Int
  name: String
}

"response of any mutation on the table \"membership_type\""
type membership_type_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [membership_type!]!
}

"aggregate stddev on columns"
type membership_type_stddev_fields {
  cost: Float
  duration_in_days: Float
  id: Float
}

"aggregate stddev_pop on columns"
type membership_type_stddev_pop_fields {
  cost: Float
  duration_in_days: Float
  id: Float
}

"aggregate stddev_samp on columns"
type membership_type_stddev_samp_fields {
  cost: Float
  duration_in_days: Float
  id: Float
}

"aggregate sum on columns"
type membership_type_sum_fields {
  cost: numeric
  duration_in_days: Int
  id: Int
}

"aggregate var_pop on columns"
type membership_type_var_pop_fields {
  cost: Float
  duration_in_days: Float
  id: Float
}

"aggregate var_samp on columns"
type membership_type_var_samp_fields {
  cost: Float
  duration_in_days: Float
  id: Float
}

"aggregate variance on columns"
type membership_type_variance_fields {
  cost: Float
  duration_in_days: Float
  id: Float
}

"aggregate var_pop on columns"
type membership_var_pop_fields {
  account_id: Float
  free_sessions_remaining: Float
  id: Float
  membership_type_id: Float
}

"aggregate var_samp on columns"
type membership_var_samp_fields {
  account_id: Float
  free_sessions_remaining: Float
  id: Float
  membership_type_id: Float
}

"aggregate variance on columns"
type membership_variance_fields {
  account_id: Float
  free_sessions_remaining: Float
  id: Float
  membership_type_id: Float
}

"mutation root"
type mutation_root {
  "delete data from the table: \"account\""
  delete_account("filter the rows which have to be deleted" where: account_bool_exp!): account_mutation_response
  "delete single row from the table: \"account\""
  delete_account_by_pk(id: Int!): account
  "delete data from the table: \"admin\""
  delete_admin("filter the rows which have to be deleted" where: admin_bool_exp!): admin_mutation_response
  "delete single row from the table: \"admin\""
  delete_admin_by_pk(id: Int!): admin
  "delete data from the table: \"assignment\""
  delete_assignment(
    "filter the rows which have to be deleted"
    where: assignment_bool_exp!
  ): assignment_mutation_response
  "delete single row from the table: \"assignment\""
  delete_assignment_by_pk(id: Int!): assignment
  "delete data from the table: \"attendance\""
  delete_attendance(
    "filter the rows which have to be deleted"
    where: attendance_bool_exp!
  ): attendance_mutation_response
  "delete single row from the table: \"attendance\""
  delete_attendance_by_pk(id: Int!): attendance
  "delete data from the table: \"blacklist\""
  delete_blacklist("filter the rows which have to be deleted" where: blacklist_bool_exp!): blacklist_mutation_response
  "delete single row from the table: \"blacklist\""
  delete_blacklist_by_pk(id: Int!): blacklist
  "delete data from the table: \"client\""
  delete_client("filter the rows which have to be deleted" where: client_bool_exp!): client_mutation_response
  "delete single row from the table: \"client\""
  delete_client_by_pk(id: Int!): client
  "delete data from the table: \"email_information\""
  delete_email_information(
    "filter the rows which have to be deleted"
    where: email_information_bool_exp!
  ): email_information_mutation_response
  "delete single row from the table: \"email_information\""
  delete_email_information_by_pk(id: Int!): email_information
  "delete data from the table: \"event\""
  delete_event("filter the rows which have to be deleted" where: event_bool_exp!): event_mutation_response
  "delete single row from the table: \"event\""
  delete_event_by_pk(id: Int!): event
  "delete data from the table: \"feedback\""
  delete_feedback("filter the rows which have to be deleted" where: feedback_bool_exp!): feedback_mutation_response
  "delete data from the table: \"interpretation_details\""
  delete_interpretation_details(
    "filter the rows which have to be deleted"
    where: interpretation_details_bool_exp!
  ): interpretation_details_mutation_response
  "delete data from the table: \"invoice\""
  delete_invoice("filter the rows which have to be deleted" where: invoice_bool_exp!): invoice_mutation_response
  "delete single row from the table: \"invoice\""
  delete_invoice_by_pk(id: Int!): invoice
  "delete data from the table: \"membership\""
  delete_membership(
    "filter the rows which have to be deleted"
    where: membership_bool_exp!
  ): membership_mutation_response
  "delete single row from the table: \"membership\""
  delete_membership_by_pk(id: Int!): membership
  "delete data from the table: \"membership_renewals\""
  delete_membership_renewals(
    "filter the rows which have to be deleted"
    where: membership_renewals_bool_exp!
  ): membership_renewals_mutation_response
  "delete single row from the table: \"membership_renewals\""
  delete_membership_renewals_by_pk(id: Int!): membership_renewals
  "delete data from the table: \"membership_type\""
  delete_membership_type(
    "filter the rows which have to be deleted"
    where: membership_type_bool_exp!
  ): membership_type_mutation_response
  "delete single row from the table: \"membership_type\""
  delete_membership_type_by_pk(id: Int!): membership_type
  "delete data from the table: \"notification_setting\""
  delete_notification_setting(
    "filter the rows which have to be deleted"
    where: notification_setting_bool_exp!
  ): notification_setting_mutation_response
  "delete single row from the table: \"notification_setting\""
  delete_notification_setting_by_pk(id: Int!): notification_setting
  "delete data from the table: \"quotation\""
  delete_quotation("filter the rows which have to be deleted" where: quotation_bool_exp!): quotation_mutation_response
  "delete single row from the table: \"quotation\""
  delete_quotation_by_pk(id: Int!): quotation
  "delete data from the table: \"service_requestor\""
  delete_service_requestor(
    "filter the rows which have to be deleted"
    where: service_requestor_bool_exp!
  ): service_requestor_mutation_response
  "delete single row from the table: \"service_requestor\""
  delete_service_requestor_by_pk(id: Int!): service_requestor
  "delete data from the table: \"telegram_information\""
  delete_telegram_information(
    "filter the rows which have to be deleted"
    where: telegram_information_bool_exp!
  ): telegram_information_mutation_response
  "delete single row from the table: \"telegram_information\""
  delete_telegram_information_by_pk(id: Int!): telegram_information
  "delete data from the table: \"volunteer\""
  delete_volunteer("filter the rows which have to be deleted" where: volunteer_bool_exp!): volunteer_mutation_response
  "delete data from the table: \"volunteer_assignment_opt_in\""
  delete_volunteer_assignment_opt_in(
    "filter the rows which have to be deleted"
    where: volunteer_assignment_opt_in_bool_exp!
  ): volunteer_assignment_opt_in_mutation_response
  "delete single row from the table: \"volunteer_assignment_opt_in\""
  delete_volunteer_assignment_opt_in_by_pk(id: Int!): volunteer_assignment_opt_in
  "delete single row from the table: \"volunteer\""
  delete_volunteer_by_pk(id: Int!): volunteer
  "insert data into the table: \"account\""
  insert_account(
    "the rows to be inserted"
    objects: [account_insert_input!]!
    "on conflict condition"
    on_conflict: account_on_conflict
  ): account_mutation_response
  "insert a single row into the table: \"account\""
  insert_account_one(
    "the row to be inserted"
    object: account_insert_input!
    "on conflict condition"
    on_conflict: account_on_conflict
  ): account
  "insert data into the table: \"admin\""
  insert_admin(
    "the rows to be inserted"
    objects: [admin_insert_input!]!
    "on conflict condition"
    on_conflict: admin_on_conflict
  ): admin_mutation_response
  "insert a single row into the table: \"admin\""
  insert_admin_one(
    "the row to be inserted"
    object: admin_insert_input!
    "on conflict condition"
    on_conflict: admin_on_conflict
  ): admin
  "insert data into the table: \"assignment\""
  insert_assignment(
    "the rows to be inserted"
    objects: [assignment_insert_input!]!
    "on conflict condition"
    on_conflict: assignment_on_conflict
  ): assignment_mutation_response
  "insert a single row into the table: \"assignment\""
  insert_assignment_one(
    "the row to be inserted"
    object: assignment_insert_input!
    "on conflict condition"
    on_conflict: assignment_on_conflict
  ): assignment
  "insert data into the table: \"attendance\""
  insert_attendance(
    "the rows to be inserted"
    objects: [attendance_insert_input!]!
    "on conflict condition"
    on_conflict: attendance_on_conflict
  ): attendance_mutation_response
  "insert a single row into the table: \"attendance\""
  insert_attendance_one(
    "the row to be inserted"
    object: attendance_insert_input!
    "on conflict condition"
    on_conflict: attendance_on_conflict
  ): attendance
  "insert data into the table: \"blacklist\""
  insert_blacklist(
    "the rows to be inserted"
    objects: [blacklist_insert_input!]!
    "on conflict condition"
    on_conflict: blacklist_on_conflict
  ): blacklist_mutation_response
  "insert a single row into the table: \"blacklist\""
  insert_blacklist_one(
    "the row to be inserted"
    object: blacklist_insert_input!
    "on conflict condition"
    on_conflict: blacklist_on_conflict
  ): blacklist
  "insert data into the table: \"client\""
  insert_client(
    "the rows to be inserted"
    objects: [client_insert_input!]!
    "on conflict condition"
    on_conflict: client_on_conflict
  ): client_mutation_response
  "insert a single row into the table: \"client\""
  insert_client_one(
    "the row to be inserted"
    object: client_insert_input!
    "on conflict condition"
    on_conflict: client_on_conflict
  ): client
  "insert data into the table: \"email_information\""
  insert_email_information(
    "the rows to be inserted"
    objects: [email_information_insert_input!]!
    "on conflict condition"
    on_conflict: email_information_on_conflict
  ): email_information_mutation_response
  "insert a single row into the table: \"email_information\""
  insert_email_information_one(
    "the row to be inserted"
    object: email_information_insert_input!
    "on conflict condition"
    on_conflict: email_information_on_conflict
  ): email_information
  "insert data into the table: \"event\""
  insert_event(
    "the rows to be inserted"
    objects: [event_insert_input!]!
    "on conflict condition"
    on_conflict: event_on_conflict
  ): event_mutation_response
  "insert a single row into the table: \"event\""
  insert_event_one(
    "the row to be inserted"
    object: event_insert_input!
    "on conflict condition"
    on_conflict: event_on_conflict
  ): event
  "insert data into the table: \"feedback\""
  insert_feedback(
    "the rows to be inserted"
    objects: [feedback_insert_input!]!
    "on conflict condition"
    on_conflict: feedback_on_conflict
  ): feedback_mutation_response
  "insert a single row into the table: \"feedback\""
  insert_feedback_one(
    "the row to be inserted"
    object: feedback_insert_input!
    "on conflict condition"
    on_conflict: feedback_on_conflict
  ): feedback
  "insert data into the table: \"interpretation_details\""
  insert_interpretation_details(
    "the rows to be inserted"
    objects: [interpretation_details_insert_input!]!
    "on conflict condition"
    on_conflict: interpretation_details_on_conflict
  ): interpretation_details_mutation_response
  "insert a single row into the table: \"interpretation_details\""
  insert_interpretation_details_one(
    "the row to be inserted"
    object: interpretation_details_insert_input!
    "on conflict condition"
    on_conflict: interpretation_details_on_conflict
  ): interpretation_details
  "insert data into the table: \"invoice\""
  insert_invoice(
    "the rows to be inserted"
    objects: [invoice_insert_input!]!
    "on conflict condition"
    on_conflict: invoice_on_conflict
  ): invoice_mutation_response
  "insert a single row into the table: \"invoice\""
  insert_invoice_one(
    "the row to be inserted"
    object: invoice_insert_input!
    "on conflict condition"
    on_conflict: invoice_on_conflict
  ): invoice
  "insert data into the table: \"membership\""
  insert_membership(
    "the rows to be inserted"
    objects: [membership_insert_input!]!
    "on conflict condition"
    on_conflict: membership_on_conflict
  ): membership_mutation_response
  "insert a single row into the table: \"membership\""
  insert_membership_one(
    "the row to be inserted"
    object: membership_insert_input!
    "on conflict condition"
    on_conflict: membership_on_conflict
  ): membership
  "insert data into the table: \"membership_renewals\""
  insert_membership_renewals(
    "the rows to be inserted"
    objects: [membership_renewals_insert_input!]!
    "on conflict condition"
    on_conflict: membership_renewals_on_conflict
  ): membership_renewals_mutation_response
  "insert a single row into the table: \"membership_renewals\""
  insert_membership_renewals_one(
    "the row to be inserted"
    object: membership_renewals_insert_input!
    "on conflict condition"
    on_conflict: membership_renewals_on_conflict
  ): membership_renewals
  "insert data into the table: \"membership_type\""
  insert_membership_type(
    "the rows to be inserted"
    objects: [membership_type_insert_input!]!
    "on conflict condition"
    on_conflict: membership_type_on_conflict
  ): membership_type_mutation_response
  "insert a single row into the table: \"membership_type\""
  insert_membership_type_one(
    "the row to be inserted"
    object: membership_type_insert_input!
    "on conflict condition"
    on_conflict: membership_type_on_conflict
  ): membership_type
  "insert data into the table: \"notification_setting\""
  insert_notification_setting(
    "the rows to be inserted"
    objects: [notification_setting_insert_input!]!
    "on conflict condition"
    on_conflict: notification_setting_on_conflict
  ): notification_setting_mutation_response
  "insert a single row into the table: \"notification_setting\""
  insert_notification_setting_one(
    "the row to be inserted"
    object: notification_setting_insert_input!
    "on conflict condition"
    on_conflict: notification_setting_on_conflict
  ): notification_setting
  "insert data into the table: \"quotation\""
  insert_quotation(
    "the rows to be inserted"
    objects: [quotation_insert_input!]!
    "on conflict condition"
    on_conflict: quotation_on_conflict
  ): quotation_mutation_response
  "insert a single row into the table: \"quotation\""
  insert_quotation_one(
    "the row to be inserted"
    object: quotation_insert_input!
    "on conflict condition"
    on_conflict: quotation_on_conflict
  ): quotation
  "insert data into the table: \"service_requestor\""
  insert_service_requestor(
    "the rows to be inserted"
    objects: [service_requestor_insert_input!]!
    "on conflict condition"
    on_conflict: service_requestor_on_conflict
  ): service_requestor_mutation_response
  "insert a single row into the table: \"service_requestor\""
  insert_service_requestor_one(
    "the row to be inserted"
    object: service_requestor_insert_input!
    "on conflict condition"
    on_conflict: service_requestor_on_conflict
  ): service_requestor
  "insert data into the table: \"telegram_information\""
  insert_telegram_information(
    "the rows to be inserted"
    objects: [telegram_information_insert_input!]!
    "on conflict condition"
    on_conflict: telegram_information_on_conflict
  ): telegram_information_mutation_response
  "insert a single row into the table: \"telegram_information\""
  insert_telegram_information_one(
    "the row to be inserted"
    object: telegram_information_insert_input!
    "on conflict condition"
    on_conflict: telegram_information_on_conflict
  ): telegram_information
  "insert data into the table: \"volunteer\""
  insert_volunteer(
    "the rows to be inserted"
    objects: [volunteer_insert_input!]!
    "on conflict condition"
    on_conflict: volunteer_on_conflict
  ): volunteer_mutation_response
  "insert data into the table: \"volunteer_assignment_opt_in\""
  insert_volunteer_assignment_opt_in(
    "the rows to be inserted"
    objects: [volunteer_assignment_opt_in_insert_input!]!
    "on conflict condition"
    on_conflict: volunteer_assignment_opt_in_on_conflict
  ): volunteer_assignment_opt_in_mutation_response
  "insert a single row into the table: \"volunteer_assignment_opt_in\""
  insert_volunteer_assignment_opt_in_one(
    "the row to be inserted"
    object: volunteer_assignment_opt_in_insert_input!
    "on conflict condition"
    on_conflict: volunteer_assignment_opt_in_on_conflict
  ): volunteer_assignment_opt_in
  "insert a single row into the table: \"volunteer\""
  insert_volunteer_one(
    "the row to be inserted"
    object: volunteer_insert_input!
    "on conflict condition"
    on_conflict: volunteer_on_conflict
  ): volunteer
  "update data of the table: \"account\""
  update_account(
    "increments the integer columns with given value of the filtered values"
    _inc: account_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: account_set_input
    "filter the rows which have to be updated"
    where: account_bool_exp!
  ): account_mutation_response
  "update single row of the table: \"account\""
  update_account_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: account_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: account_set_input
    pk_columns: account_pk_columns_input!
  ): account
  "update data of the table: \"admin\""
  update_admin(
    "increments the integer columns with given value of the filtered values"
    _inc: admin_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: admin_set_input
    "filter the rows which have to be updated"
    where: admin_bool_exp!
  ): admin_mutation_response
  "update single row of the table: \"admin\""
  update_admin_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: admin_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: admin_set_input
    pk_columns: admin_pk_columns_input!
  ): admin
  "update data of the table: \"assignment\""
  update_assignment(
    "increments the integer columns with given value of the filtered values"
    _inc: assignment_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: assignment_set_input
    "filter the rows which have to be updated"
    where: assignment_bool_exp!
  ): assignment_mutation_response
  "update single row of the table: \"assignment\""
  update_assignment_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: assignment_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: assignment_set_input
    pk_columns: assignment_pk_columns_input!
  ): assignment
  "update data of the table: \"attendance\""
  update_attendance(
    "increments the integer columns with given value of the filtered values"
    _inc: attendance_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: attendance_set_input
    "filter the rows which have to be updated"
    where: attendance_bool_exp!
  ): attendance_mutation_response
  "update single row of the table: \"attendance\""
  update_attendance_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: attendance_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: attendance_set_input
    pk_columns: attendance_pk_columns_input!
  ): attendance
  "update data of the table: \"blacklist\""
  update_blacklist(
    "increments the integer columns with given value of the filtered values"
    _inc: blacklist_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: blacklist_set_input
    "filter the rows which have to be updated"
    where: blacklist_bool_exp!
  ): blacklist_mutation_response
  "update single row of the table: \"blacklist\""
  update_blacklist_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: blacklist_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: blacklist_set_input
    pk_columns: blacklist_pk_columns_input!
  ): blacklist
  "update data of the table: \"client\""
  update_client(
    "increments the integer columns with given value of the filtered values"
    _inc: client_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: client_set_input
    "filter the rows which have to be updated"
    where: client_bool_exp!
  ): client_mutation_response
  "update single row of the table: \"client\""
  update_client_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: client_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: client_set_input
    pk_columns: client_pk_columns_input!
  ): client
  "update data of the table: \"email_information\""
  update_email_information(
    "increments the integer columns with given value of the filtered values"
    _inc: email_information_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: email_information_set_input
    "filter the rows which have to be updated"
    where: email_information_bool_exp!
  ): email_information_mutation_response
  "update single row of the table: \"email_information\""
  update_email_information_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: email_information_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: email_information_set_input
    pk_columns: email_information_pk_columns_input!
  ): email_information
  "update data of the table: \"event\""
  update_event(
    "increments the integer columns with given value of the filtered values"
    _inc: event_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: event_set_input
    "filter the rows which have to be updated"
    where: event_bool_exp!
  ): event_mutation_response
  "update single row of the table: \"event\""
  update_event_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: event_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: event_set_input
    pk_columns: event_pk_columns_input!
  ): event
  "update data of the table: \"feedback\""
  update_feedback(
    "increments the integer columns with given value of the filtered values"
    _inc: feedback_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: feedback_set_input
    "filter the rows which have to be updated"
    where: feedback_bool_exp!
  ): feedback_mutation_response
  "update data of the table: \"interpretation_details\""
  update_interpretation_details(
    "increments the integer columns with given value of the filtered values"
    _inc: interpretation_details_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: interpretation_details_set_input
    "filter the rows which have to be updated"
    where: interpretation_details_bool_exp!
  ): interpretation_details_mutation_response
  "update data of the table: \"invoice\""
  update_invoice(
    "increments the integer columns with given value of the filtered values"
    _inc: invoice_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: invoice_set_input
    "filter the rows which have to be updated"
    where: invoice_bool_exp!
  ): invoice_mutation_response
  "update single row of the table: \"invoice\""
  update_invoice_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: invoice_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: invoice_set_input
    pk_columns: invoice_pk_columns_input!
  ): invoice
  "update data of the table: \"membership\""
  update_membership(
    "increments the integer columns with given value of the filtered values"
    _inc: membership_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: membership_set_input
    "filter the rows which have to be updated"
    where: membership_bool_exp!
  ): membership_mutation_response
  "update single row of the table: \"membership\""
  update_membership_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: membership_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: membership_set_input
    pk_columns: membership_pk_columns_input!
  ): membership
  "update data of the table: \"membership_renewals\""
  update_membership_renewals(
    "increments the integer columns with given value of the filtered values"
    _inc: membership_renewals_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: membership_renewals_set_input
    "filter the rows which have to be updated"
    where: membership_renewals_bool_exp!
  ): membership_renewals_mutation_response
  "update single row of the table: \"membership_renewals\""
  update_membership_renewals_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: membership_renewals_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: membership_renewals_set_input
    pk_columns: membership_renewals_pk_columns_input!
  ): membership_renewals
  "update data of the table: \"membership_type\""
  update_membership_type(
    "increments the integer columns with given value of the filtered values"
    _inc: membership_type_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: membership_type_set_input
    "filter the rows which have to be updated"
    where: membership_type_bool_exp!
  ): membership_type_mutation_response
  "update single row of the table: \"membership_type\""
  update_membership_type_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: membership_type_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: membership_type_set_input
    pk_columns: membership_type_pk_columns_input!
  ): membership_type
  "update data of the table: \"notification_setting\""
  update_notification_setting(
    "increments the integer columns with given value of the filtered values"
    _inc: notification_setting_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: notification_setting_set_input
    "filter the rows which have to be updated"
    where: notification_setting_bool_exp!
  ): notification_setting_mutation_response
  "update single row of the table: \"notification_setting\""
  update_notification_setting_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: notification_setting_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: notification_setting_set_input
    pk_columns: notification_setting_pk_columns_input!
  ): notification_setting
  "update data of the table: \"quotation\""
  update_quotation(
    "increments the integer columns with given value of the filtered values"
    _inc: quotation_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: quotation_set_input
    "filter the rows which have to be updated"
    where: quotation_bool_exp!
  ): quotation_mutation_response
  "update single row of the table: \"quotation\""
  update_quotation_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: quotation_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: quotation_set_input
    pk_columns: quotation_pk_columns_input!
  ): quotation
  "update data of the table: \"service_requestor\""
  update_service_requestor(
    "increments the integer columns with given value of the filtered values"
    _inc: service_requestor_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: service_requestor_set_input
    "filter the rows which have to be updated"
    where: service_requestor_bool_exp!
  ): service_requestor_mutation_response
  "update single row of the table: \"service_requestor\""
  update_service_requestor_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: service_requestor_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: service_requestor_set_input
    pk_columns: service_requestor_pk_columns_input!
  ): service_requestor
  "update data of the table: \"telegram_information\""
  update_telegram_information(
    "increments the integer columns with given value of the filtered values"
    _inc: telegram_information_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: telegram_information_set_input
    "filter the rows which have to be updated"
    where: telegram_information_bool_exp!
  ): telegram_information_mutation_response
  "update single row of the table: \"telegram_information\""
  update_telegram_information_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: telegram_information_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: telegram_information_set_input
    pk_columns: telegram_information_pk_columns_input!
  ): telegram_information
  "update data of the table: \"volunteer\""
  update_volunteer(
    "increments the integer columns with given value of the filtered values"
    _inc: volunteer_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: volunteer_set_input
    "filter the rows which have to be updated"
    where: volunteer_bool_exp!
  ): volunteer_mutation_response
  "update data of the table: \"volunteer_assignment_opt_in\""
  update_volunteer_assignment_opt_in(
    "increments the integer columns with given value of the filtered values"
    _inc: volunteer_assignment_opt_in_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: volunteer_assignment_opt_in_set_input
    "filter the rows which have to be updated"
    where: volunteer_assignment_opt_in_bool_exp!
  ): volunteer_assignment_opt_in_mutation_response
  "update single row of the table: \"volunteer_assignment_opt_in\""
  update_volunteer_assignment_opt_in_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: volunteer_assignment_opt_in_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: volunteer_assignment_opt_in_set_input
    pk_columns: volunteer_assignment_opt_in_pk_columns_input!
  ): volunteer_assignment_opt_in
  "update single row of the table: \"volunteer\""
  update_volunteer_by_pk(
    "increments the integer columns with given value of the filtered values"
    _inc: volunteer_inc_input
    "sets the columns of the filtered rows to the given values"
    _set: volunteer_set_input
    pk_columns: volunteer_pk_columns_input!
  ): volunteer
}

"columns and relationships of \"notification_setting\""
type notification_setting {
  "An object relationship"
  account: account!
  account_id: Int!
  client_matched: Boolean
  client_unmatched: Boolean
  "An object relationship"
  email_information: email_information
  id: Int!
  "An object relationship"
  telegram_information: telegram_information
  volunteer_matched: Boolean
  volunteer_new: Boolean
  volunteer_periodic: Boolean
  volunteer_urgent: Boolean
}

"aggregated selection of \"notification_setting\""
type notification_setting_aggregate {
  aggregate: notification_setting_aggregate_fields
  nodes: [notification_setting!]!
}

"aggregate fields of \"notification_setting\""
type notification_setting_aggregate_fields {
  avg: notification_setting_avg_fields
  count(columns: [notification_setting_select_column!], distinct: Boolean): Int
  max: notification_setting_max_fields
  min: notification_setting_min_fields
  stddev: notification_setting_stddev_fields
  stddev_pop: notification_setting_stddev_pop_fields
  stddev_samp: notification_setting_stddev_samp_fields
  sum: notification_setting_sum_fields
  var_pop: notification_setting_var_pop_fields
  var_samp: notification_setting_var_samp_fields
  variance: notification_setting_variance_fields
}

"aggregate avg on columns"
type notification_setting_avg_fields {
  account_id: Float
  id: Float
}

"aggregate max on columns"
type notification_setting_max_fields {
  account_id: Int
  id: Int
}

"aggregate min on columns"
type notification_setting_min_fields {
  account_id: Int
  id: Int
}

"response of any mutation on the table \"notification_setting\""
type notification_setting_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [notification_setting!]!
}

"aggregate stddev on columns"
type notification_setting_stddev_fields {
  account_id: Float
  id: Float
}

"aggregate stddev_pop on columns"
type notification_setting_stddev_pop_fields {
  account_id: Float
  id: Float
}

"aggregate stddev_samp on columns"
type notification_setting_stddev_samp_fields {
  account_id: Float
  id: Float
}

"aggregate sum on columns"
type notification_setting_sum_fields {
  account_id: Int
  id: Int
}

"aggregate var_pop on columns"
type notification_setting_var_pop_fields {
  account_id: Float
  id: Float
}

"aggregate var_samp on columns"
type notification_setting_var_samp_fields {
  account_id: Float
  id: Float
}

"aggregate variance on columns"
type notification_setting_variance_fields {
  account_id: Float
  id: Float
}

"query root"
type query_root {
  "fetch data from the table: \"account\""
  account(
    "distinct select on columns"
    distinct_on: [account_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [account_order_by!]
    "filter the rows returned"
    where: account_bool_exp
  ): [account!]!
  "fetch aggregated fields from the table: \"account\""
  account_aggregate(
    "distinct select on columns"
    distinct_on: [account_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [account_order_by!]
    "filter the rows returned"
    where: account_bool_exp
  ): account_aggregate!
  "fetch data from the table: \"account\" using primary key columns"
  account_by_pk(id: Int!): account
  "fetch data from the table: \"admin\""
  admin(
    "distinct select on columns"
    distinct_on: [admin_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [admin_order_by!]
    "filter the rows returned"
    where: admin_bool_exp
  ): [admin!]!
  "fetch aggregated fields from the table: \"admin\""
  admin_aggregate(
    "distinct select on columns"
    distinct_on: [admin_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [admin_order_by!]
    "filter the rows returned"
    where: admin_bool_exp
  ): admin_aggregate!
  "fetch data from the table: \"admin\" using primary key columns"
  admin_by_pk(id: Int!): admin
  "fetch data from the table: \"assignment\""
  assignment(
    "distinct select on columns"
    distinct_on: [assignment_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assignment_order_by!]
    "filter the rows returned"
    where: assignment_bool_exp
  ): [assignment!]!
  "fetch aggregated fields from the table: \"assignment\""
  assignment_aggregate(
    "distinct select on columns"
    distinct_on: [assignment_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assignment_order_by!]
    "filter the rows returned"
    where: assignment_bool_exp
  ): assignment_aggregate!
  "fetch data from the table: \"assignment\" using primary key columns"
  assignment_by_pk(id: Int!): assignment
  "fetch data from the table: \"attendance\""
  attendance(
    "distinct select on columns"
    distinct_on: [attendance_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [attendance_order_by!]
    "filter the rows returned"
    where: attendance_bool_exp
  ): [attendance!]!
  "fetch aggregated fields from the table: \"attendance\""
  attendance_aggregate(
    "distinct select on columns"
    distinct_on: [attendance_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [attendance_order_by!]
    "filter the rows returned"
    where: attendance_bool_exp
  ): attendance_aggregate!
  "fetch data from the table: \"attendance\" using primary key columns"
  attendance_by_pk(id: Int!): attendance
  "fetch data from the table: \"blacklist\""
  blacklist(
    "distinct select on columns"
    distinct_on: [blacklist_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [blacklist_order_by!]
    "filter the rows returned"
    where: blacklist_bool_exp
  ): [blacklist!]!
  "fetch aggregated fields from the table: \"blacklist\""
  blacklist_aggregate(
    "distinct select on columns"
    distinct_on: [blacklist_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [blacklist_order_by!]
    "filter the rows returned"
    where: blacklist_bool_exp
  ): blacklist_aggregate!
  "fetch data from the table: \"blacklist\" using primary key columns"
  blacklist_by_pk(id: Int!): blacklist
  "fetch data from the table: \"client\""
  client(
    "distinct select on columns"
    distinct_on: [client_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [client_order_by!]
    "filter the rows returned"
    where: client_bool_exp
  ): [client!]!
  "fetch aggregated fields from the table: \"client\""
  client_aggregate(
    "distinct select on columns"
    distinct_on: [client_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [client_order_by!]
    "filter the rows returned"
    where: client_bool_exp
  ): client_aggregate!
  "fetch data from the table: \"client\" using primary key columns"
  client_by_pk(id: Int!): client
  "fetch data from the table: \"email_information\""
  email_information(
    "distinct select on columns"
    distinct_on: [email_information_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [email_information_order_by!]
    "filter the rows returned"
    where: email_information_bool_exp
  ): [email_information!]!
  "fetch aggregated fields from the table: \"email_information\""
  email_information_aggregate(
    "distinct select on columns"
    distinct_on: [email_information_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [email_information_order_by!]
    "filter the rows returned"
    where: email_information_bool_exp
  ): email_information_aggregate!
  "fetch data from the table: \"email_information\" using primary key columns"
  email_information_by_pk(id: Int!): email_information
  "fetch data from the table: \"event\""
  event(
    "distinct select on columns"
    distinct_on: [event_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [event_order_by!]
    "filter the rows returned"
    where: event_bool_exp
  ): [event!]!
  "fetch aggregated fields from the table: \"event\""
  event_aggregate(
    "distinct select on columns"
    distinct_on: [event_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [event_order_by!]
    "filter the rows returned"
    where: event_bool_exp
  ): event_aggregate!
  "fetch data from the table: \"event\" using primary key columns"
  event_by_pk(id: Int!): event
  "fetch data from the table: \"feedback\""
  feedback(
    "distinct select on columns"
    distinct_on: [feedback_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [feedback_order_by!]
    "filter the rows returned"
    where: feedback_bool_exp
  ): [feedback!]!
  "fetch aggregated fields from the table: \"feedback\""
  feedback_aggregate(
    "distinct select on columns"
    distinct_on: [feedback_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [feedback_order_by!]
    "filter the rows returned"
    where: feedback_bool_exp
  ): feedback_aggregate!
  "fetch data from the table: \"interpretation_details\""
  interpretation_details(
    "distinct select on columns"
    distinct_on: [interpretation_details_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [interpretation_details_order_by!]
    "filter the rows returned"
    where: interpretation_details_bool_exp
  ): [interpretation_details!]!
  "fetch aggregated fields from the table: \"interpretation_details\""
  interpretation_details_aggregate(
    "distinct select on columns"
    distinct_on: [interpretation_details_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [interpretation_details_order_by!]
    "filter the rows returned"
    where: interpretation_details_bool_exp
  ): interpretation_details_aggregate!
  "fetch data from the table: \"invoice\""
  invoice(
    "distinct select on columns"
    distinct_on: [invoice_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [invoice_order_by!]
    "filter the rows returned"
    where: invoice_bool_exp
  ): [invoice!]!
  "fetch aggregated fields from the table: \"invoice\""
  invoice_aggregate(
    "distinct select on columns"
    distinct_on: [invoice_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [invoice_order_by!]
    "filter the rows returned"
    where: invoice_bool_exp
  ): invoice_aggregate!
  "fetch data from the table: \"invoice\" using primary key columns"
  invoice_by_pk(id: Int!): invoice
  "fetch data from the table: \"membership\""
  membership(
    "distinct select on columns"
    distinct_on: [membership_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [membership_order_by!]
    "filter the rows returned"
    where: membership_bool_exp
  ): [membership!]!
  "fetch aggregated fields from the table: \"membership\""
  membership_aggregate(
    "distinct select on columns"
    distinct_on: [membership_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [membership_order_by!]
    "filter the rows returned"
    where: membership_bool_exp
  ): membership_aggregate!
  "fetch data from the table: \"membership\" using primary key columns"
  membership_by_pk(id: Int!): membership
  "fetch data from the table: \"membership_renewals\""
  membership_renewals(
    "distinct select on columns"
    distinct_on: [membership_renewals_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [membership_renewals_order_by!]
    "filter the rows returned"
    where: membership_renewals_bool_exp
  ): [membership_renewals!]!
  "fetch aggregated fields from the table: \"membership_renewals\""
  membership_renewals_aggregate(
    "distinct select on columns"
    distinct_on: [membership_renewals_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [membership_renewals_order_by!]
    "filter the rows returned"
    where: membership_renewals_bool_exp
  ): membership_renewals_aggregate!
  "fetch data from the table: \"membership_renewals\" using primary key columns"
  membership_renewals_by_pk(id: Int!): membership_renewals
  "fetch data from the table: \"membership_type\""
  membership_type(
    "distinct select on columns"
    distinct_on: [membership_type_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [membership_type_order_by!]
    "filter the rows returned"
    where: membership_type_bool_exp
  ): [membership_type!]!
  "fetch aggregated fields from the table: \"membership_type\""
  membership_type_aggregate(
    "distinct select on columns"
    distinct_on: [membership_type_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [membership_type_order_by!]
    "filter the rows returned"
    where: membership_type_bool_exp
  ): membership_type_aggregate!
  "fetch data from the table: \"membership_type\" using primary key columns"
  membership_type_by_pk(id: Int!): membership_type
  "fetch data from the table: \"notification_setting\""
  notification_setting(
    "distinct select on columns"
    distinct_on: [notification_setting_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [notification_setting_order_by!]
    "filter the rows returned"
    where: notification_setting_bool_exp
  ): [notification_setting!]!
  "fetch aggregated fields from the table: \"notification_setting\""
  notification_setting_aggregate(
    "distinct select on columns"
    distinct_on: [notification_setting_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [notification_setting_order_by!]
    "filter the rows returned"
    where: notification_setting_bool_exp
  ): notification_setting_aggregate!
  "fetch data from the table: \"notification_setting\" using primary key columns"
  notification_setting_by_pk(id: Int!): notification_setting
  "fetch data from the table: \"quotation\""
  quotation(
    "distinct select on columns"
    distinct_on: [quotation_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [quotation_order_by!]
    "filter the rows returned"
    where: quotation_bool_exp
  ): [quotation!]!
  "fetch aggregated fields from the table: \"quotation\""
  quotation_aggregate(
    "distinct select on columns"
    distinct_on: [quotation_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [quotation_order_by!]
    "filter the rows returned"
    where: quotation_bool_exp
  ): quotation_aggregate!
  "fetch data from the table: \"quotation\" using primary key columns"
  quotation_by_pk(id: Int!): quotation
  "fetch data from the table: \"service_requestor\""
  service_requestor(
    "distinct select on columns"
    distinct_on: [service_requestor_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [service_requestor_order_by!]
    "filter the rows returned"
    where: service_requestor_bool_exp
  ): [service_requestor!]!
  "fetch aggregated fields from the table: \"service_requestor\""
  service_requestor_aggregate(
    "distinct select on columns"
    distinct_on: [service_requestor_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [service_requestor_order_by!]
    "filter the rows returned"
    where: service_requestor_bool_exp
  ): service_requestor_aggregate!
  "fetch data from the table: \"service_requestor\" using primary key columns"
  service_requestor_by_pk(id: Int!): service_requestor
  "fetch data from the table: \"telegram_information\""
  telegram_information(
    "distinct select on columns"
    distinct_on: [telegram_information_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [telegram_information_order_by!]
    "filter the rows returned"
    where: telegram_information_bool_exp
  ): [telegram_information!]!
  "fetch aggregated fields from the table: \"telegram_information\""
  telegram_information_aggregate(
    "distinct select on columns"
    distinct_on: [telegram_information_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [telegram_information_order_by!]
    "filter the rows returned"
    where: telegram_information_bool_exp
  ): telegram_information_aggregate!
  "fetch data from the table: \"telegram_information\" using primary key columns"
  telegram_information_by_pk(id: Int!): telegram_information
  "fetch data from the table: \"volunteer\""
  volunteer(
    "distinct select on columns"
    distinct_on: [volunteer_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [volunteer_order_by!]
    "filter the rows returned"
    where: volunteer_bool_exp
  ): [volunteer!]!
  "fetch aggregated fields from the table: \"volunteer\""
  volunteer_aggregate(
    "distinct select on columns"
    distinct_on: [volunteer_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [volunteer_order_by!]
    "filter the rows returned"
    where: volunteer_bool_exp
  ): volunteer_aggregate!
  "fetch data from the table: \"volunteer_assignment_opt_in\""
  volunteer_assignment_opt_in(
    "distinct select on columns"
    distinct_on: [volunteer_assignment_opt_in_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [volunteer_assignment_opt_in_order_by!]
    "filter the rows returned"
    where: volunteer_assignment_opt_in_bool_exp
  ): [volunteer_assignment_opt_in!]!
  "fetch aggregated fields from the table: \"volunteer_assignment_opt_in\""
  volunteer_assignment_opt_in_aggregate(
    "distinct select on columns"
    distinct_on: [volunteer_assignment_opt_in_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [volunteer_assignment_opt_in_order_by!]
    "filter the rows returned"
    where: volunteer_assignment_opt_in_bool_exp
  ): volunteer_assignment_opt_in_aggregate!
  "fetch data from the table: \"volunteer_assignment_opt_in\" using primary key columns"
  volunteer_assignment_opt_in_by_pk(id: Int!): volunteer_assignment_opt_in
  "fetch data from the table: \"volunteer\" using primary key columns"
  volunteer_by_pk(id: Int!): volunteer
}

"""
Reference - https://sadeaf.org.sg/service/notetaking/


columns and relationships of "quotation"
"""
type quotation {
  created_at: timestamptz!
  fee_for_first_block: numeric!
  fee_per_subsequent_block: numeric!
  first_block_duration_m: Int!
  id: Int!
  requestor_type: String!
  subsequent_block_duration_m: Int!
  updated_at: timestamptz!
}

"aggregated selection of \"quotation\""
type quotation_aggregate {
  aggregate: quotation_aggregate_fields
  nodes: [quotation!]!
}

"aggregate fields of \"quotation\""
type quotation_aggregate_fields {
  avg: quotation_avg_fields
  count(columns: [quotation_select_column!], distinct: Boolean): Int
  max: quotation_max_fields
  min: quotation_min_fields
  stddev: quotation_stddev_fields
  stddev_pop: quotation_stddev_pop_fields
  stddev_samp: quotation_stddev_samp_fields
  sum: quotation_sum_fields
  var_pop: quotation_var_pop_fields
  var_samp: quotation_var_samp_fields
  variance: quotation_variance_fields
}

"aggregate avg on columns"
type quotation_avg_fields {
  fee_for_first_block: Float
  fee_per_subsequent_block: Float
  first_block_duration_m: Float
  id: Float
  subsequent_block_duration_m: Float
}

"aggregate max on columns"
type quotation_max_fields {
  created_at: timestamptz
  fee_for_first_block: numeric
  fee_per_subsequent_block: numeric
  first_block_duration_m: Int
  id: Int
  requestor_type: String
  subsequent_block_duration_m: Int
  updated_at: timestamptz
}

"aggregate min on columns"
type quotation_min_fields {
  created_at: timestamptz
  fee_for_first_block: numeric
  fee_per_subsequent_block: numeric
  first_block_duration_m: Int
  id: Int
  requestor_type: String
  subsequent_block_duration_m: Int
  updated_at: timestamptz
}

"response of any mutation on the table \"quotation\""
type quotation_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [quotation!]!
}

"aggregate stddev on columns"
type quotation_stddev_fields {
  fee_for_first_block: Float
  fee_per_subsequent_block: Float
  first_block_duration_m: Float
  id: Float
  subsequent_block_duration_m: Float
}

"aggregate stddev_pop on columns"
type quotation_stddev_pop_fields {
  fee_for_first_block: Float
  fee_per_subsequent_block: Float
  first_block_duration_m: Float
  id: Float
  subsequent_block_duration_m: Float
}

"aggregate stddev_samp on columns"
type quotation_stddev_samp_fields {
  fee_for_first_block: Float
  fee_per_subsequent_block: Float
  first_block_duration_m: Float
  id: Float
  subsequent_block_duration_m: Float
}

"aggregate sum on columns"
type quotation_sum_fields {
  fee_for_first_block: numeric
  fee_per_subsequent_block: numeric
  first_block_duration_m: Int
  id: Int
  subsequent_block_duration_m: Int
}

"aggregate var_pop on columns"
type quotation_var_pop_fields {
  fee_for_first_block: Float
  fee_per_subsequent_block: Float
  first_block_duration_m: Float
  id: Float
  subsequent_block_duration_m: Float
}

"aggregate var_samp on columns"
type quotation_var_samp_fields {
  fee_for_first_block: Float
  fee_per_subsequent_block: Float
  first_block_duration_m: Float
  id: Float
  subsequent_block_duration_m: Float
}

"aggregate variance on columns"
type quotation_variance_fields {
  fee_for_first_block: Float
  fee_per_subsequent_block: Float
  first_block_duration_m: Float
  id: Float
  subsequent_block_duration_m: Float
}

"columns and relationships of \"service_requestor\""
type service_requestor {
  "An object relationship"
  account: account!
  account_id: Int!
  "An array relationship"
  clients(
    "distinct select on columns"
    distinct_on: [client_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [client_order_by!]
    "filter the rows returned"
    where: client_bool_exp
  ): [client!]!
  "An aggregated array relationship"
  clients_aggregate(
    "distinct select on columns"
    distinct_on: [client_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [client_order_by!]
    "filter the rows returned"
    where: client_bool_exp
  ): client_aggregate!
  id: Int!
  "An object relationship"
  membership: membership!
  membership_id: Int!
  organisation: String!
}

"aggregated selection of \"service_requestor\""
type service_requestor_aggregate {
  aggregate: service_requestor_aggregate_fields
  nodes: [service_requestor!]!
}

"aggregate fields of \"service_requestor\""
type service_requestor_aggregate_fields {
  avg: service_requestor_avg_fields
  count(columns: [service_requestor_select_column!], distinct: Boolean): Int
  max: service_requestor_max_fields
  min: service_requestor_min_fields
  stddev: service_requestor_stddev_fields
  stddev_pop: service_requestor_stddev_pop_fields
  stddev_samp: service_requestor_stddev_samp_fields
  sum: service_requestor_sum_fields
  var_pop: service_requestor_var_pop_fields
  var_samp: service_requestor_var_samp_fields
  variance: service_requestor_variance_fields
}

"aggregate avg on columns"
type service_requestor_avg_fields {
  account_id: Float
  id: Float
  membership_id: Float
}

"aggregate max on columns"
type service_requestor_max_fields {
  account_id: Int
  id: Int
  membership_id: Int
  organisation: String
}

"aggregate min on columns"
type service_requestor_min_fields {
  account_id: Int
  id: Int
  membership_id: Int
  organisation: String
}

"response of any mutation on the table \"service_requestor\""
type service_requestor_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [service_requestor!]!
}

"aggregate stddev on columns"
type service_requestor_stddev_fields {
  account_id: Float
  id: Float
  membership_id: Float
}

"aggregate stddev_pop on columns"
type service_requestor_stddev_pop_fields {
  account_id: Float
  id: Float
  membership_id: Float
}

"aggregate stddev_samp on columns"
type service_requestor_stddev_samp_fields {
  account_id: Float
  id: Float
  membership_id: Float
}

"aggregate sum on columns"
type service_requestor_sum_fields {
  account_id: Int
  id: Int
  membership_id: Int
}

"aggregate var_pop on columns"
type service_requestor_var_pop_fields {
  account_id: Float
  id: Float
  membership_id: Float
}

"aggregate var_samp on columns"
type service_requestor_var_samp_fields {
  account_id: Float
  id: Float
  membership_id: Float
}

"aggregate variance on columns"
type service_requestor_variance_fields {
  account_id: Float
  id: Float
  membership_id: Float
}

"subscription root"
type subscription_root {
  "fetch data from the table: \"account\""
  account(
    "distinct select on columns"
    distinct_on: [account_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [account_order_by!]
    "filter the rows returned"
    where: account_bool_exp
  ): [account!]!
  "fetch aggregated fields from the table: \"account\""
  account_aggregate(
    "distinct select on columns"
    distinct_on: [account_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [account_order_by!]
    "filter the rows returned"
    where: account_bool_exp
  ): account_aggregate!
  "fetch data from the table: \"account\" using primary key columns"
  account_by_pk(id: Int!): account
  "fetch data from the table: \"admin\""
  admin(
    "distinct select on columns"
    distinct_on: [admin_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [admin_order_by!]
    "filter the rows returned"
    where: admin_bool_exp
  ): [admin!]!
  "fetch aggregated fields from the table: \"admin\""
  admin_aggregate(
    "distinct select on columns"
    distinct_on: [admin_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [admin_order_by!]
    "filter the rows returned"
    where: admin_bool_exp
  ): admin_aggregate!
  "fetch data from the table: \"admin\" using primary key columns"
  admin_by_pk(id: Int!): admin
  "fetch data from the table: \"assignment\""
  assignment(
    "distinct select on columns"
    distinct_on: [assignment_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assignment_order_by!]
    "filter the rows returned"
    where: assignment_bool_exp
  ): [assignment!]!
  "fetch aggregated fields from the table: \"assignment\""
  assignment_aggregate(
    "distinct select on columns"
    distinct_on: [assignment_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assignment_order_by!]
    "filter the rows returned"
    where: assignment_bool_exp
  ): assignment_aggregate!
  "fetch data from the table: \"assignment\" using primary key columns"
  assignment_by_pk(id: Int!): assignment
  "fetch data from the table: \"attendance\""
  attendance(
    "distinct select on columns"
    distinct_on: [attendance_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [attendance_order_by!]
    "filter the rows returned"
    where: attendance_bool_exp
  ): [attendance!]!
  "fetch aggregated fields from the table: \"attendance\""
  attendance_aggregate(
    "distinct select on columns"
    distinct_on: [attendance_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [attendance_order_by!]
    "filter the rows returned"
    where: attendance_bool_exp
  ): attendance_aggregate!
  "fetch data from the table: \"attendance\" using primary key columns"
  attendance_by_pk(id: Int!): attendance
  "fetch data from the table: \"blacklist\""
  blacklist(
    "distinct select on columns"
    distinct_on: [blacklist_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [blacklist_order_by!]
    "filter the rows returned"
    where: blacklist_bool_exp
  ): [blacklist!]!
  "fetch aggregated fields from the table: \"blacklist\""
  blacklist_aggregate(
    "distinct select on columns"
    distinct_on: [blacklist_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [blacklist_order_by!]
    "filter the rows returned"
    where: blacklist_bool_exp
  ): blacklist_aggregate!
  "fetch data from the table: \"blacklist\" using primary key columns"
  blacklist_by_pk(id: Int!): blacklist
  "fetch data from the table: \"client\""
  client(
    "distinct select on columns"
    distinct_on: [client_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [client_order_by!]
    "filter the rows returned"
    where: client_bool_exp
  ): [client!]!
  "fetch aggregated fields from the table: \"client\""
  client_aggregate(
    "distinct select on columns"
    distinct_on: [client_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [client_order_by!]
    "filter the rows returned"
    where: client_bool_exp
  ): client_aggregate!
  "fetch data from the table: \"client\" using primary key columns"
  client_by_pk(id: Int!): client
  "fetch data from the table: \"email_information\""
  email_information(
    "distinct select on columns"
    distinct_on: [email_information_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [email_information_order_by!]
    "filter the rows returned"
    where: email_information_bool_exp
  ): [email_information!]!
  "fetch aggregated fields from the table: \"email_information\""
  email_information_aggregate(
    "distinct select on columns"
    distinct_on: [email_information_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [email_information_order_by!]
    "filter the rows returned"
    where: email_information_bool_exp
  ): email_information_aggregate!
  "fetch data from the table: \"email_information\" using primary key columns"
  email_information_by_pk(id: Int!): email_information
  "fetch data from the table: \"event\""
  event(
    "distinct select on columns"
    distinct_on: [event_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [event_order_by!]
    "filter the rows returned"
    where: event_bool_exp
  ): [event!]!
  "fetch aggregated fields from the table: \"event\""
  event_aggregate(
    "distinct select on columns"
    distinct_on: [event_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [event_order_by!]
    "filter the rows returned"
    where: event_bool_exp
  ): event_aggregate!
  "fetch data from the table: \"event\" using primary key columns"
  event_by_pk(id: Int!): event
  "fetch data from the table: \"feedback\""
  feedback(
    "distinct select on columns"
    distinct_on: [feedback_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [feedback_order_by!]
    "filter the rows returned"
    where: feedback_bool_exp
  ): [feedback!]!
  "fetch aggregated fields from the table: \"feedback\""
  feedback_aggregate(
    "distinct select on columns"
    distinct_on: [feedback_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [feedback_order_by!]
    "filter the rows returned"
    where: feedback_bool_exp
  ): feedback_aggregate!
  "fetch data from the table: \"interpretation_details\""
  interpretation_details(
    "distinct select on columns"
    distinct_on: [interpretation_details_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [interpretation_details_order_by!]
    "filter the rows returned"
    where: interpretation_details_bool_exp
  ): [interpretation_details!]!
  "fetch aggregated fields from the table: \"interpretation_details\""
  interpretation_details_aggregate(
    "distinct select on columns"
    distinct_on: [interpretation_details_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [interpretation_details_order_by!]
    "filter the rows returned"
    where: interpretation_details_bool_exp
  ): interpretation_details_aggregate!
  "fetch data from the table: \"invoice\""
  invoice(
    "distinct select on columns"
    distinct_on: [invoice_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [invoice_order_by!]
    "filter the rows returned"
    where: invoice_bool_exp
  ): [invoice!]!
  "fetch aggregated fields from the table: \"invoice\""
  invoice_aggregate(
    "distinct select on columns"
    distinct_on: [invoice_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [invoice_order_by!]
    "filter the rows returned"
    where: invoice_bool_exp
  ): invoice_aggregate!
  "fetch data from the table: \"invoice\" using primary key columns"
  invoice_by_pk(id: Int!): invoice
  "fetch data from the table: \"membership\""
  membership(
    "distinct select on columns"
    distinct_on: [membership_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [membership_order_by!]
    "filter the rows returned"
    where: membership_bool_exp
  ): [membership!]!
  "fetch aggregated fields from the table: \"membership\""
  membership_aggregate(
    "distinct select on columns"
    distinct_on: [membership_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [membership_order_by!]
    "filter the rows returned"
    where: membership_bool_exp
  ): membership_aggregate!
  "fetch data from the table: \"membership\" using primary key columns"
  membership_by_pk(id: Int!): membership
  "fetch data from the table: \"membership_renewals\""
  membership_renewals(
    "distinct select on columns"
    distinct_on: [membership_renewals_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [membership_renewals_order_by!]
    "filter the rows returned"
    where: membership_renewals_bool_exp
  ): [membership_renewals!]!
  "fetch aggregated fields from the table: \"membership_renewals\""
  membership_renewals_aggregate(
    "distinct select on columns"
    distinct_on: [membership_renewals_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [membership_renewals_order_by!]
    "filter the rows returned"
    where: membership_renewals_bool_exp
  ): membership_renewals_aggregate!
  "fetch data from the table: \"membership_renewals\" using primary key columns"
  membership_renewals_by_pk(id: Int!): membership_renewals
  "fetch data from the table: \"membership_type\""
  membership_type(
    "distinct select on columns"
    distinct_on: [membership_type_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [membership_type_order_by!]
    "filter the rows returned"
    where: membership_type_bool_exp
  ): [membership_type!]!
  "fetch aggregated fields from the table: \"membership_type\""
  membership_type_aggregate(
    "distinct select on columns"
    distinct_on: [membership_type_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [membership_type_order_by!]
    "filter the rows returned"
    where: membership_type_bool_exp
  ): membership_type_aggregate!
  "fetch data from the table: \"membership_type\" using primary key columns"
  membership_type_by_pk(id: Int!): membership_type
  "fetch data from the table: \"notification_setting\""
  notification_setting(
    "distinct select on columns"
    distinct_on: [notification_setting_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [notification_setting_order_by!]
    "filter the rows returned"
    where: notification_setting_bool_exp
  ): [notification_setting!]!
  "fetch aggregated fields from the table: \"notification_setting\""
  notification_setting_aggregate(
    "distinct select on columns"
    distinct_on: [notification_setting_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [notification_setting_order_by!]
    "filter the rows returned"
    where: notification_setting_bool_exp
  ): notification_setting_aggregate!
  "fetch data from the table: \"notification_setting\" using primary key columns"
  notification_setting_by_pk(id: Int!): notification_setting
  "fetch data from the table: \"quotation\""
  quotation(
    "distinct select on columns"
    distinct_on: [quotation_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [quotation_order_by!]
    "filter the rows returned"
    where: quotation_bool_exp
  ): [quotation!]!
  "fetch aggregated fields from the table: \"quotation\""
  quotation_aggregate(
    "distinct select on columns"
    distinct_on: [quotation_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [quotation_order_by!]
    "filter the rows returned"
    where: quotation_bool_exp
  ): quotation_aggregate!
  "fetch data from the table: \"quotation\" using primary key columns"
  quotation_by_pk(id: Int!): quotation
  "fetch data from the table: \"service_requestor\""
  service_requestor(
    "distinct select on columns"
    distinct_on: [service_requestor_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [service_requestor_order_by!]
    "filter the rows returned"
    where: service_requestor_bool_exp
  ): [service_requestor!]!
  "fetch aggregated fields from the table: \"service_requestor\""
  service_requestor_aggregate(
    "distinct select on columns"
    distinct_on: [service_requestor_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [service_requestor_order_by!]
    "filter the rows returned"
    where: service_requestor_bool_exp
  ): service_requestor_aggregate!
  "fetch data from the table: \"service_requestor\" using primary key columns"
  service_requestor_by_pk(id: Int!): service_requestor
  "fetch data from the table: \"telegram_information\""
  telegram_information(
    "distinct select on columns"
    distinct_on: [telegram_information_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [telegram_information_order_by!]
    "filter the rows returned"
    where: telegram_information_bool_exp
  ): [telegram_information!]!
  "fetch aggregated fields from the table: \"telegram_information\""
  telegram_information_aggregate(
    "distinct select on columns"
    distinct_on: [telegram_information_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [telegram_information_order_by!]
    "filter the rows returned"
    where: telegram_information_bool_exp
  ): telegram_information_aggregate!
  "fetch data from the table: \"telegram_information\" using primary key columns"
  telegram_information_by_pk(id: Int!): telegram_information
  "fetch data from the table: \"volunteer\""
  volunteer(
    "distinct select on columns"
    distinct_on: [volunteer_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [volunteer_order_by!]
    "filter the rows returned"
    where: volunteer_bool_exp
  ): [volunteer!]!
  "fetch aggregated fields from the table: \"volunteer\""
  volunteer_aggregate(
    "distinct select on columns"
    distinct_on: [volunteer_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [volunteer_order_by!]
    "filter the rows returned"
    where: volunteer_bool_exp
  ): volunteer_aggregate!
  "fetch data from the table: \"volunteer_assignment_opt_in\""
  volunteer_assignment_opt_in(
    "distinct select on columns"
    distinct_on: [volunteer_assignment_opt_in_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [volunteer_assignment_opt_in_order_by!]
    "filter the rows returned"
    where: volunteer_assignment_opt_in_bool_exp
  ): [volunteer_assignment_opt_in!]!
  "fetch aggregated fields from the table: \"volunteer_assignment_opt_in\""
  volunteer_assignment_opt_in_aggregate(
    "distinct select on columns"
    distinct_on: [volunteer_assignment_opt_in_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [volunteer_assignment_opt_in_order_by!]
    "filter the rows returned"
    where: volunteer_assignment_opt_in_bool_exp
  ): volunteer_assignment_opt_in_aggregate!
  "fetch data from the table: \"volunteer_assignment_opt_in\" using primary key columns"
  volunteer_assignment_opt_in_by_pk(id: Int!): volunteer_assignment_opt_in
  "fetch data from the table: \"volunteer\" using primary key columns"
  volunteer_by_pk(id: Int!): volunteer
}

"columns and relationships of \"telegram_information\""
type telegram_information {
  chat_id: bigint
  id: Int!
  "An object relationship"
  notification_setting: notification_setting!
  notification_setting_id: Int!
  user_handle: String!
}

"aggregated selection of \"telegram_information\""
type telegram_information_aggregate {
  aggregate: telegram_information_aggregate_fields
  nodes: [telegram_information!]!
}

"aggregate fields of \"telegram_information\""
type telegram_information_aggregate_fields {
  avg: telegram_information_avg_fields
  count(columns: [telegram_information_select_column!], distinct: Boolean): Int
  max: telegram_information_max_fields
  min: telegram_information_min_fields
  stddev: telegram_information_stddev_fields
  stddev_pop: telegram_information_stddev_pop_fields
  stddev_samp: telegram_information_stddev_samp_fields
  sum: telegram_information_sum_fields
  var_pop: telegram_information_var_pop_fields
  var_samp: telegram_information_var_samp_fields
  variance: telegram_information_variance_fields
}

"aggregate avg on columns"
type telegram_information_avg_fields {
  chat_id: Float
  id: Float
  notification_setting_id: Float
}

"aggregate max on columns"
type telegram_information_max_fields {
  chat_id: bigint
  id: Int
  notification_setting_id: Int
  user_handle: String
}

"aggregate min on columns"
type telegram_information_min_fields {
  chat_id: bigint
  id: Int
  notification_setting_id: Int
  user_handle: String
}

"response of any mutation on the table \"telegram_information\""
type telegram_information_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [telegram_information!]!
}

"aggregate stddev on columns"
type telegram_information_stddev_fields {
  chat_id: Float
  id: Float
  notification_setting_id: Float
}

"aggregate stddev_pop on columns"
type telegram_information_stddev_pop_fields {
  chat_id: Float
  id: Float
  notification_setting_id: Float
}

"aggregate stddev_samp on columns"
type telegram_information_stddev_samp_fields {
  chat_id: Float
  id: Float
  notification_setting_id: Float
}

"aggregate sum on columns"
type telegram_information_sum_fields {
  chat_id: bigint
  id: Int
  notification_setting_id: Int
}

"aggregate var_pop on columns"
type telegram_information_var_pop_fields {
  chat_id: Float
  id: Float
  notification_setting_id: Float
}

"aggregate var_samp on columns"
type telegram_information_var_samp_fields {
  chat_id: Float
  id: Float
  notification_setting_id: Float
}

"aggregate variance on columns"
type telegram_information_variance_fields {
  chat_id: Float
  id: Float
  notification_setting_id: Float
}

"columns and relationships of \"volunteer\""
type volunteer {
  "An object relationship"
  account: account!
  account_id: Int!
  approval_status: Boolean!
  "An array relationship"
  assignments(
    "distinct select on columns"
    distinct_on: [assignment_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assignment_order_by!]
    "filter the rows returned"
    where: assignment_bool_exp
  ): [assignment!]!
  "An aggregated array relationship"
  assignments_aggregate(
    "distinct select on columns"
    distinct_on: [assignment_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [assignment_order_by!]
    "filter the rows returned"
    where: assignment_bool_exp
  ): assignment_aggregate!
  "An array relationship"
  blacklists(
    "distinct select on columns"
    distinct_on: [blacklist_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [blacklist_order_by!]
    "filter the rows returned"
    where: blacklist_bool_exp
  ): [blacklist!]!
  "An aggregated array relationship"
  blacklists_aggregate(
    "distinct select on columns"
    distinct_on: [blacklist_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [blacklist_order_by!]
    "filter the rows returned"
    where: blacklist_bool_exp
  ): blacklist_aggregate!
  "An array relationship"
  feedbacks(
    "distinct select on columns"
    distinct_on: [feedback_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [feedback_order_by!]
    "filter the rows returned"
    where: feedback_bool_exp
  ): [feedback!]!
  "An aggregated array relationship"
  feedbacks_aggregate(
    "distinct select on columns"
    distinct_on: [feedback_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [feedback_order_by!]
    "filter the rows returned"
    where: feedback_bool_exp
  ): feedback_aggregate!
  id: Int!
  interpreter: Boolean!
  notetaker: Boolean!
  "An array relationship"
  volunteer_assignment_opt_ins(
    "distinct select on columns"
    distinct_on: [volunteer_assignment_opt_in_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [volunteer_assignment_opt_in_order_by!]
    "filter the rows returned"
    where: volunteer_assignment_opt_in_bool_exp
  ): [volunteer_assignment_opt_in!]!
  "An aggregated array relationship"
  volunteer_assignment_opt_ins_aggregate(
    "distinct select on columns"
    distinct_on: [volunteer_assignment_opt_in_select_column!]
    "limit the number of rows returned"
    limit: Int
    "skip the first n rows. Use only with order_by"
    offset: Int
    "sort the rows by one or more columns"
    order_by: [volunteer_assignment_opt_in_order_by!]
    "filter the rows returned"
    where: volunteer_assignment_opt_in_bool_exp
  ): volunteer_assignment_opt_in_aggregate!
}

"aggregated selection of \"volunteer\""
type volunteer_aggregate {
  aggregate: volunteer_aggregate_fields
  nodes: [volunteer!]!
}

"aggregate fields of \"volunteer\""
type volunteer_aggregate_fields {
  avg: volunteer_avg_fields
  count(columns: [volunteer_select_column!], distinct: Boolean): Int
  max: volunteer_max_fields
  min: volunteer_min_fields
  stddev: volunteer_stddev_fields
  stddev_pop: volunteer_stddev_pop_fields
  stddev_samp: volunteer_stddev_samp_fields
  sum: volunteer_sum_fields
  var_pop: volunteer_var_pop_fields
  var_samp: volunteer_var_samp_fields
  variance: volunteer_variance_fields
}

"columns and relationships of \"volunteer_assignment_opt_in\""
type volunteer_assignment_opt_in {
  "An object relationship"
  assignment: assignment!
  assignment_id: Int!
  created_at: timestamptz!
  id: Int!
  status: String!
  "An object relationship"
  volunteer: volunteer!
  volunteer_id: Int!
}

"aggregated selection of \"volunteer_assignment_opt_in\""
type volunteer_assignment_opt_in_aggregate {
  aggregate: volunteer_assignment_opt_in_aggregate_fields
  nodes: [volunteer_assignment_opt_in!]!
}

"aggregate fields of \"volunteer_assignment_opt_in\""
type volunteer_assignment_opt_in_aggregate_fields {
  avg: volunteer_assignment_opt_in_avg_fields
  count(columns: [volunteer_assignment_opt_in_select_column!], distinct: Boolean): Int
  max: volunteer_assignment_opt_in_max_fields
  min: volunteer_assignment_opt_in_min_fields
  stddev: volunteer_assignment_opt_in_stddev_fields
  stddev_pop: volunteer_assignment_opt_in_stddev_pop_fields
  stddev_samp: volunteer_assignment_opt_in_stddev_samp_fields
  sum: volunteer_assignment_opt_in_sum_fields
  var_pop: volunteer_assignment_opt_in_var_pop_fields
  var_samp: volunteer_assignment_opt_in_var_samp_fields
  variance: volunteer_assignment_opt_in_variance_fields
}

"aggregate avg on columns"
type volunteer_assignment_opt_in_avg_fields {
  assignment_id: Float
  id: Float
  volunteer_id: Float
}

"aggregate max on columns"
type volunteer_assignment_opt_in_max_fields {
  assignment_id: Int
  created_at: timestamptz
  id: Int
  status: String
  volunteer_id: Int
}

"aggregate min on columns"
type volunteer_assignment_opt_in_min_fields {
  assignment_id: Int
  created_at: timestamptz
  id: Int
  status: String
  volunteer_id: Int
}

"response of any mutation on the table \"volunteer_assignment_opt_in\""
type volunteer_assignment_opt_in_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [volunteer_assignment_opt_in!]!
}

"aggregate stddev on columns"
type volunteer_assignment_opt_in_stddev_fields {
  assignment_id: Float
  id: Float
  volunteer_id: Float
}

"aggregate stddev_pop on columns"
type volunteer_assignment_opt_in_stddev_pop_fields {
  assignment_id: Float
  id: Float
  volunteer_id: Float
}

"aggregate stddev_samp on columns"
type volunteer_assignment_opt_in_stddev_samp_fields {
  assignment_id: Float
  id: Float
  volunteer_id: Float
}

"aggregate sum on columns"
type volunteer_assignment_opt_in_sum_fields {
  assignment_id: Int
  id: Int
  volunteer_id: Int
}

"aggregate var_pop on columns"
type volunteer_assignment_opt_in_var_pop_fields {
  assignment_id: Float
  id: Float
  volunteer_id: Float
}

"aggregate var_samp on columns"
type volunteer_assignment_opt_in_var_samp_fields {
  assignment_id: Float
  id: Float
  volunteer_id: Float
}

"aggregate variance on columns"
type volunteer_assignment_opt_in_variance_fields {
  assignment_id: Float
  id: Float
  volunteer_id: Float
}

"aggregate avg on columns"
type volunteer_avg_fields {
  account_id: Float
  id: Float
}

"aggregate max on columns"
type volunteer_max_fields {
  account_id: Int
  id: Int
}

"aggregate min on columns"
type volunteer_min_fields {
  account_id: Int
  id: Int
}

"response of any mutation on the table \"volunteer\""
type volunteer_mutation_response {
  "number of affected rows by the mutation"
  affected_rows: Int!
  "data of the affected rows by the mutation"
  returning: [volunteer!]!
}

"aggregate stddev on columns"
type volunteer_stddev_fields {
  account_id: Float
  id: Float
}

"aggregate stddev_pop on columns"
type volunteer_stddev_pop_fields {
  account_id: Float
  id: Float
}

"aggregate stddev_samp on columns"
type volunteer_stddev_samp_fields {
  account_id: Float
  id: Float
}

"aggregate sum on columns"
type volunteer_sum_fields {
  account_id: Int
  id: Int
}

"aggregate var_pop on columns"
type volunteer_var_pop_fields {
  account_id: Float
  id: Float
}

"aggregate var_samp on columns"
type volunteer_var_samp_fields {
  account_id: Float
  id: Float
}

"aggregate variance on columns"
type volunteer_variance_fields {
  account_id: Float
  id: Float
}

"unique or primary key constraints on table \"account\""
enum account_constraint {
  "unique or primary key constraint"
  account_cognito_id_key
  "unique or primary key constraint"
  account_email_key
  "unique or primary key constraint"
  account_pkey
}

"select columns of table \"account\""
enum account_select_column {
  "column name"
  cognito_id
  "column name"
  contact
  "column name"
  created_at
  "column name"
  email
  "column name"
  id
  "column name"
  is_enabled
  "column name"
  name
  "column name"
  profile_pic_url
  "column name"
  role
  "column name"
  updated_at
}

"update columns of table \"account\""
enum account_update_column {
  "column name"
  cognito_id
  "column name"
  contact
  "column name"
  created_at
  "column name"
  email
  "column name"
  id
  "column name"
  is_enabled
  "column name"
  name
  "column name"
  profile_pic_url
  "column name"
  role
  "column name"
  updated_at
}

"unique or primary key constraints on table \"admin\""
enum admin_constraint {
  "unique or primary key constraint"
  admin_account_id_key
  "unique or primary key constraint"
  admin_pkey
}

"select columns of table \"admin\""
enum admin_select_column {
  "column name"
  account_id
  "column name"
  id
}

"update columns of table \"admin\""
enum admin_update_column {
  "column name"
  account_id
  "column name"
  id
}

"unique or primary key constraints on table \"assignment\""
enum assignment_constraint {
  "unique or primary key constraint"
  assignment_pkey
}

"select columns of table \"assignment\""
enum assignment_select_column {
  "column name"
  address_line_one
  "column name"
  address_line_two
  "column name"
  end_dt
  "column name"
  event_id
  "column name"
  honorarium_amount
  "column name"
  id
  "column name"
  latitude
  "column name"
  longitude
  "column name"
  postal
  "column name"
  room_number
  "column name"
  start_dt
  "column name"
  status
  "column name"
  volunteer_id
}

"update columns of table \"assignment\""
enum assignment_update_column {
  "column name"
  address_line_one
  "column name"
  address_line_two
  "column name"
  end_dt
  "column name"
  event_id
  "column name"
  honorarium_amount
  "column name"
  id
  "column name"
  latitude
  "column name"
  longitude
  "column name"
  postal
  "column name"
  room_number
  "column name"
  start_dt
  "column name"
  status
  "column name"
  volunteer_id
}

"unique or primary key constraints on table \"attendance\""
enum attendance_constraint {
  "unique or primary key constraint"
  attendance_assignment_id_key
  "unique or primary key constraint"
  attendance_pkey
}

"select columns of table \"attendance\""
enum attendance_select_column {
  "column name"
  assignment_id
  "column name"
  attended
  "column name"
  dispute_comment
  "column name"
  has_dispute
  "column name"
  id
}

"update columns of table \"attendance\""
enum attendance_update_column {
  "column name"
  assignment_id
  "column name"
  attended
  "column name"
  dispute_comment
  "column name"
  has_dispute
  "column name"
  id
}

"unique or primary key constraints on table \"blacklist\""
enum blacklist_constraint {
  "unique or primary key constraint"
  blacklist_client_account_id_volunteer_account_id_key
  "unique or primary key constraint"
  blacklist_pkey
}

"select columns of table \"blacklist\""
enum blacklist_select_column {
  "column name"
  client_account_id
  "column name"
  id
  "column name"
  volunteer_account_id
}

"update columns of table \"blacklist\""
enum blacklist_update_column {
  "column name"
  client_account_id
  "column name"
  id
  "column name"
  volunteer_account_id
}

"unique or primary key constraints on table \"client\""
enum client_constraint {
  "unique or primary key constraint"
  client_account_id_key
  "unique or primary key constraint"
  client_pkey
}

"select columns of table \"client\""
enum client_select_column {
  "column name"
  account_id
  "column name"
  additional_notes
  "column name"
  designation
  "column name"
  id
  "column name"
  organisation
  "column name"
  preferred_comm_mode
  "column name"
  quotation_id
  "column name"
  service_requestor_id
}

"update columns of table \"client\""
enum client_update_column {
  "column name"
  account_id
  "column name"
  additional_notes
  "column name"
  designation
  "column name"
  id
  "column name"
  organisation
  "column name"
  preferred_comm_mode
  "column name"
  quotation_id
  "column name"
  service_requestor_id
}

"unique or primary key constraints on table \"email_information\""
enum email_information_constraint {
  "unique or primary key constraint"
  email_information_notification_setting_id_key
  "unique or primary key constraint"
  email_information_pkey
}

"select columns of table \"email_information\""
enum email_information_select_column {
  "column name"
  id
  "column name"
  notification_setting_id
}

"update columns of table \"email_information\""
enum email_information_update_column {
  "column name"
  id
  "column name"
  notification_setting_id
}

"unique or primary key constraints on table \"event\""
enum event_constraint {
  "unique or primary key constraint"
  event_pkey
}

"select columns of table \"event\""
enum event_select_column {
  "column name"
  client_id
  "column name"
  created_at
  "column name"
  description
  "column name"
  id
  "column name"
  interpreter_required
  "column name"
  name
  "column name"
  notetaker_required
  "column name"
  purpose
  "column name"
  updated_at
}

"update columns of table \"event\""
enum event_update_column {
  "column name"
  client_id
  "column name"
  created_at
  "column name"
  description
  "column name"
  id
  "column name"
  interpreter_required
  "column name"
  name
  "column name"
  notetaker_required
  "column name"
  purpose
  "column name"
  updated_at
}

"unique or primary key constraints on table \"feedback\""
enum feedback_constraint {
  "unique or primary key constraint"
  feedback_event_id_volunteer_id_key
  "unique or primary key constraint"
  feedback_id_key
}

"select columns of table \"feedback\""
enum feedback_select_column {
  "column name"
  confidentiality_privacy_preference
  "column name"
  created_at
  "column name"
  event_id
  "column name"
  feedback_given
  "column name"
  general_feedback
  "column name"
  id
  "column name"
  live_comments
  "column name"
  live_information_understanding
  "column name"
  live_interaction
  "column name"
  notetaker_conduct
  "column name"
  notetaker_punctual
  "column name"
  post_session_comments
  "column name"
  post_session_understanding
  "column name"
  training_privacy_preference
  "column name"
  updated_at
  "column name"
  volunteer_id
}

"update columns of table \"feedback\""
enum feedback_update_column {
  "column name"
  confidentiality_privacy_preference
  "column name"
  created_at
  "column name"
  event_id
  "column name"
  feedback_given
  "column name"
  general_feedback
  "column name"
  id
  "column name"
  live_comments
  "column name"
  live_information_understanding
  "column name"
  live_interaction
  "column name"
  notetaker_conduct
  "column name"
  notetaker_punctual
  "column name"
  post_session_comments
  "column name"
  post_session_understanding
  "column name"
  training_privacy_preference
  "column name"
  updated_at
  "column name"
  volunteer_id
}

"unique or primary key constraints on table \"interpretation_details\""
enum interpretation_details_constraint {
  "unique or primary key constraint"
  interpretation_details_event_id_key
}

"select columns of table \"interpretation_details\""
enum interpretation_details_select_column {
  "column name"
  allow_trainee_interpreters
  "column name"
  event_id
  "column name"
  filming_interpreters
  "column name"
  id
  "column name"
  number_of_deaf
  "column name"
  number_of_hearing
  "column name"
  sign_system
}

"update columns of table \"interpretation_details\""
enum interpretation_details_update_column {
  "column name"
  allow_trainee_interpreters
  "column name"
  event_id
  "column name"
  filming_interpreters
  "column name"
  id
  "column name"
  number_of_deaf
  "column name"
  number_of_hearing
  "column name"
  sign_system
}

"unique or primary key constraints on table \"invoice\""
enum invoice_constraint {
  "unique or primary key constraint"
  invoice_event_id_key
  "unique or primary key constraint"
  invoice_pkey
}

"select columns of table \"invoice\""
enum invoice_select_column {
  "column name"
  amount
  "column name"
  created_at
  "column name"
  event_id
  "column name"
  id
  "column name"
  name
  "column name"
  updated_at
}

"update columns of table \"invoice\""
enum invoice_update_column {
  "column name"
  amount
  "column name"
  created_at
  "column name"
  event_id
  "column name"
  id
  "column name"
  name
  "column name"
  updated_at
}

"unique or primary key constraints on table \"membership\""
enum membership_constraint {
  "unique or primary key constraint"
  membership_account_id_membership_type_id_status_key
  "unique or primary key constraint"
  membership_pkey
}

"unique or primary key constraints on table \"membership_renewals\""
enum membership_renewals_constraint {
  "unique or primary key constraint"
  membership_renewals_pkey
}

"select columns of table \"membership_renewals\""
enum membership_renewals_select_column {
  "column name"
  created_at
  "column name"
  id
  "column name"
  membership_id
}

"update columns of table \"membership_renewals\""
enum membership_renewals_update_column {
  "column name"
  created_at
  "column name"
  id
  "column name"
  membership_id
}

"select columns of table \"membership\""
enum membership_select_column {
  "column name"
  account_id
  "column name"
  created_at
  "column name"
  free_sessions_remaining
  "column name"
  id
  "column name"
  membership_type_id
  "column name"
  status
  "column name"
  updated_at
}

"unique or primary key constraints on table \"membership_type\""
enum membership_type_constraint {
  "unique or primary key constraint"
  membership_type_name_key
  "unique or primary key constraint"
  membership_type_pkey
}

"select columns of table \"membership_type\""
enum membership_type_select_column {
  "column name"
  cost
  "column name"
  description
  "column name"
  duration_in_days
  "column name"
  id
  "column name"
  name
}

"update columns of table \"membership_type\""
enum membership_type_update_column {
  "column name"
  cost
  "column name"
  description
  "column name"
  duration_in_days
  "column name"
  id
  "column name"
  name
}

"update columns of table \"membership\""
enum membership_update_column {
  "column name"
  account_id
  "column name"
  created_at
  "column name"
  free_sessions_remaining
  "column name"
  id
  "column name"
  membership_type_id
  "column name"
  status
  "column name"
  updated_at
}

"unique or primary key constraints on table \"notification_setting\""
enum notification_setting_constraint {
  "unique or primary key constraint"
  notification_setting_account_id_key
  "unique or primary key constraint"
  notification_setting_pkey
}

"select columns of table \"notification_setting\""
enum notification_setting_select_column {
  "column name"
  account_id
  "column name"
  client_matched
  "column name"
  client_unmatched
  "column name"
  id
  "column name"
  volunteer_matched
  "column name"
  volunteer_new
  "column name"
  volunteer_periodic
  "column name"
  volunteer_urgent
}

"update columns of table \"notification_setting\""
enum notification_setting_update_column {
  "column name"
  account_id
  "column name"
  client_matched
  "column name"
  client_unmatched
  "column name"
  id
  "column name"
  volunteer_matched
  "column name"
  volunteer_new
  "column name"
  volunteer_periodic
  "column name"
  volunteer_urgent
}

"column ordering options"
enum order_by {
  "in the ascending order, nulls last"
  asc
  "in the ascending order, nulls first"
  asc_nulls_first
  "in the ascending order, nulls last"
  asc_nulls_last
  "in the descending order, nulls first"
  desc
  "in the descending order, nulls first"
  desc_nulls_first
  "in the descending order, nulls last"
  desc_nulls_last
}

"unique or primary key constraints on table \"quotation\""
enum quotation_constraint {
  "unique or primary key constraint"
  quotation_pkey
  "unique or primary key constraint"
  quotation_requestor_type_key
}

"select columns of table \"quotation\""
enum quotation_select_column {
  "column name"
  created_at
  "column name"
  fee_for_first_block
  "column name"
  fee_per_subsequent_block
  "column name"
  first_block_duration_m
  "column name"
  id
  "column name"
  requestor_type
  "column name"
  subsequent_block_duration_m
  "column name"
  updated_at
}

"update columns of table \"quotation\""
enum quotation_update_column {
  "column name"
  created_at
  "column name"
  fee_for_first_block
  "column name"
  fee_per_subsequent_block
  "column name"
  first_block_duration_m
  "column name"
  id
  "column name"
  requestor_type
  "column name"
  subsequent_block_duration_m
  "column name"
  updated_at
}

"unique or primary key constraints on table \"service_requestor\""
enum service_requestor_constraint {
  "unique or primary key constraint"
  service_requestor_account_id_key
  "unique or primary key constraint"
  service_requestor_pkey
}

"select columns of table \"service_requestor\""
enum service_requestor_select_column {
  "column name"
  account_id
  "column name"
  id
  "column name"
  membership_id
  "column name"
  organisation
}

"update columns of table \"service_requestor\""
enum service_requestor_update_column {
  "column name"
  account_id
  "column name"
  id
  "column name"
  membership_id
  "column name"
  organisation
}

"unique or primary key constraints on table \"telegram_information\""
enum telegram_information_constraint {
  "unique or primary key constraint"
  telegram_information_notification_setting_id_key
  "unique or primary key constraint"
  telegram_information_pkey
}

"select columns of table \"telegram_information\""
enum telegram_information_select_column {
  "column name"
  chat_id
  "column name"
  id
  "column name"
  notification_setting_id
  "column name"
  user_handle
}

"update columns of table \"telegram_information\""
enum telegram_information_update_column {
  "column name"
  chat_id
  "column name"
  id
  "column name"
  notification_setting_id
  "column name"
  user_handle
}

"unique or primary key constraints on table \"volunteer_assignment_opt_in\""
enum volunteer_assignment_opt_in_constraint {
  "unique or primary key constraint"
  volunteer_assignment_opt_in_pkey
  "unique or primary key constraint"
  volunteer_assignment_opt_in_volunteer_id_assignment_id_key
}

"select columns of table \"volunteer_assignment_opt_in\""
enum volunteer_assignment_opt_in_select_column {
  "column name"
  assignment_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  status
  "column name"
  volunteer_id
}

"update columns of table \"volunteer_assignment_opt_in\""
enum volunteer_assignment_opt_in_update_column {
  "column name"
  assignment_id
  "column name"
  created_at
  "column name"
  id
  "column name"
  status
  "column name"
  volunteer_id
}

"unique or primary key constraints on table \"volunteer\""
enum volunteer_constraint {
  "unique or primary key constraint"
  volunteer_account_id_key
  "unique or primary key constraint"
  volunteer_pkey
}

"select columns of table \"volunteer\""
enum volunteer_select_column {
  "column name"
  account_id
  "column name"
  approval_status
  "column name"
  id
  "column name"
  interpreter
  "column name"
  notetaker
}

"update columns of table \"volunteer\""
enum volunteer_update_column {
  "column name"
  account_id
  "column name"
  approval_status
  "column name"
  id
  "column name"
  interpreter
  "column name"
  notetaker
}

"expression to compare columns of type Boolean. All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"expression to compare columns of type Int. All fields are combined with logical 'AND'."
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"expression to compare columns of type String. All fields are combined with logical 'AND'."
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

"order by aggregate values of table \"account\""
input account_aggregate_order_by {
  avg: account_avg_order_by
  count: order_by
  max: account_max_order_by
  min: account_min_order_by
  stddev: account_stddev_order_by
  stddev_pop: account_stddev_pop_order_by
  stddev_samp: account_stddev_samp_order_by
  sum: account_sum_order_by
  var_pop: account_var_pop_order_by
  var_samp: account_var_samp_order_by
  variance: account_variance_order_by
}

"input type for inserting array relation for remote table \"account\""
input account_arr_rel_insert_input {
  data: [account_insert_input!]!
  on_conflict: account_on_conflict
}

"order by avg() on columns of table \"account\""
input account_avg_order_by {
  id: order_by
}

"Boolean expression to filter rows from the table \"account\". All fields are combined with a logical 'AND'."
input account_bool_exp {
  _and: [account_bool_exp]
  _not: account_bool_exp
  _or: [account_bool_exp]
  admin: admin_bool_exp
  client: client_bool_exp
  cognito_id: String_comparison_exp
  contact: String_comparison_exp
  created_at: timestamp_comparison_exp
  email: String_comparison_exp
  id: Int_comparison_exp
  is_enabled: Boolean_comparison_exp
  memberships: membership_bool_exp
  name: String_comparison_exp
  notification_setting: notification_setting_bool_exp
  profile_pic_url: String_comparison_exp
  role: String_comparison_exp
  service_requestor: service_requestor_bool_exp
  updated_at: timestamp_comparison_exp
  volunteer: volunteer_bool_exp
}

"input type for incrementing integer column in table \"account\""
input account_inc_input {
  id: Int
}

"input type for inserting data into table \"account\""
input account_insert_input {
  admin: admin_obj_rel_insert_input
  client: client_obj_rel_insert_input
  cognito_id: String
  contact: String
  created_at: timestamp
  email: String
  id: Int
  is_enabled: Boolean
  memberships: membership_arr_rel_insert_input
  name: String
  notification_setting: notification_setting_obj_rel_insert_input
  profile_pic_url: String
  role: String
  service_requestor: service_requestor_obj_rel_insert_input
  updated_at: timestamp
  volunteer: volunteer_obj_rel_insert_input
}

"order by max() on columns of table \"account\""
input account_max_order_by {
  cognito_id: order_by
  contact: order_by
  created_at: order_by
  email: order_by
  id: order_by
  name: order_by
  profile_pic_url: order_by
  role: order_by
  updated_at: order_by
}

"order by min() on columns of table \"account\""
input account_min_order_by {
  cognito_id: order_by
  contact: order_by
  created_at: order_by
  email: order_by
  id: order_by
  name: order_by
  profile_pic_url: order_by
  role: order_by
  updated_at: order_by
}

"input type for inserting object relation for remote table \"account\""
input account_obj_rel_insert_input {
  data: account_insert_input!
  on_conflict: account_on_conflict
}

"on conflict condition type for table \"account\""
input account_on_conflict {
  constraint: account_constraint!
  update_columns: [account_update_column!]!
  where: account_bool_exp
}

"ordering options when selecting data from \"account\""
input account_order_by {
  admin: admin_order_by
  client: client_order_by
  cognito_id: order_by
  contact: order_by
  created_at: order_by
  email: order_by
  id: order_by
  is_enabled: order_by
  memberships_aggregate: membership_aggregate_order_by
  name: order_by
  notification_setting: notification_setting_order_by
  profile_pic_url: order_by
  role: order_by
  service_requestor: service_requestor_order_by
  updated_at: order_by
  volunteer: volunteer_order_by
}

"primary key columns input for table: \"account\""
input account_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"account\""
input account_set_input {
  cognito_id: String
  contact: String
  created_at: timestamp
  email: String
  id: Int
  is_enabled: Boolean
  name: String
  profile_pic_url: String
  role: String
  updated_at: timestamp
}

"order by stddev() on columns of table \"account\""
input account_stddev_order_by {
  id: order_by
}

"order by stddev_pop() on columns of table \"account\""
input account_stddev_pop_order_by {
  id: order_by
}

"order by stddev_samp() on columns of table \"account\""
input account_stddev_samp_order_by {
  id: order_by
}

"order by sum() on columns of table \"account\""
input account_sum_order_by {
  id: order_by
}

"order by var_pop() on columns of table \"account\""
input account_var_pop_order_by {
  id: order_by
}

"order by var_samp() on columns of table \"account\""
input account_var_samp_order_by {
  id: order_by
}

"order by variance() on columns of table \"account\""
input account_variance_order_by {
  id: order_by
}

"order by aggregate values of table \"admin\""
input admin_aggregate_order_by {
  avg: admin_avg_order_by
  count: order_by
  max: admin_max_order_by
  min: admin_min_order_by
  stddev: admin_stddev_order_by
  stddev_pop: admin_stddev_pop_order_by
  stddev_samp: admin_stddev_samp_order_by
  sum: admin_sum_order_by
  var_pop: admin_var_pop_order_by
  var_samp: admin_var_samp_order_by
  variance: admin_variance_order_by
}

"input type for inserting array relation for remote table \"admin\""
input admin_arr_rel_insert_input {
  data: [admin_insert_input!]!
  on_conflict: admin_on_conflict
}

"order by avg() on columns of table \"admin\""
input admin_avg_order_by {
  account_id: order_by
  id: order_by
}

"Boolean expression to filter rows from the table \"admin\". All fields are combined with a logical 'AND'."
input admin_bool_exp {
  _and: [admin_bool_exp]
  _not: admin_bool_exp
  _or: [admin_bool_exp]
  account: account_bool_exp
  account_id: Int_comparison_exp
  id: Int_comparison_exp
}

"input type for incrementing integer column in table \"admin\""
input admin_inc_input {
  account_id: Int
  id: Int
}

"input type for inserting data into table \"admin\""
input admin_insert_input {
  account: account_obj_rel_insert_input
  account_id: Int
  id: Int
}

"order by max() on columns of table \"admin\""
input admin_max_order_by {
  account_id: order_by
  id: order_by
}

"order by min() on columns of table \"admin\""
input admin_min_order_by {
  account_id: order_by
  id: order_by
}

"input type for inserting object relation for remote table \"admin\""
input admin_obj_rel_insert_input {
  data: admin_insert_input!
  on_conflict: admin_on_conflict
}

"on conflict condition type for table \"admin\""
input admin_on_conflict {
  constraint: admin_constraint!
  update_columns: [admin_update_column!]!
  where: admin_bool_exp
}

"ordering options when selecting data from \"admin\""
input admin_order_by {
  account: account_order_by
  account_id: order_by
  id: order_by
}

"primary key columns input for table: \"admin\""
input admin_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"admin\""
input admin_set_input {
  account_id: Int
  id: Int
}

"order by stddev() on columns of table \"admin\""
input admin_stddev_order_by {
  account_id: order_by
  id: order_by
}

"order by stddev_pop() on columns of table \"admin\""
input admin_stddev_pop_order_by {
  account_id: order_by
  id: order_by
}

"order by stddev_samp() on columns of table \"admin\""
input admin_stddev_samp_order_by {
  account_id: order_by
  id: order_by
}

"order by sum() on columns of table \"admin\""
input admin_sum_order_by {
  account_id: order_by
  id: order_by
}

"order by var_pop() on columns of table \"admin\""
input admin_var_pop_order_by {
  account_id: order_by
  id: order_by
}

"order by var_samp() on columns of table \"admin\""
input admin_var_samp_order_by {
  account_id: order_by
  id: order_by
}

"order by variance() on columns of table \"admin\""
input admin_variance_order_by {
  account_id: order_by
  id: order_by
}

"order by aggregate values of table \"assignment\""
input assignment_aggregate_order_by {
  avg: assignment_avg_order_by
  count: order_by
  max: assignment_max_order_by
  min: assignment_min_order_by
  stddev: assignment_stddev_order_by
  stddev_pop: assignment_stddev_pop_order_by
  stddev_samp: assignment_stddev_samp_order_by
  sum: assignment_sum_order_by
  var_pop: assignment_var_pop_order_by
  var_samp: assignment_var_samp_order_by
  variance: assignment_variance_order_by
}

"input type for inserting array relation for remote table \"assignment\""
input assignment_arr_rel_insert_input {
  data: [assignment_insert_input!]!
  on_conflict: assignment_on_conflict
}

"order by avg() on columns of table \"assignment\""
input assignment_avg_order_by {
  event_id: order_by
  honorarium_amount: order_by
  id: order_by
  latitude: order_by
  longitude: order_by
  volunteer_id: order_by
}

"Boolean expression to filter rows from the table \"assignment\". All fields are combined with a logical 'AND'."
input assignment_bool_exp {
  _and: [assignment_bool_exp]
  _not: assignment_bool_exp
  _or: [assignment_bool_exp]
  address_line_one: String_comparison_exp
  address_line_two: String_comparison_exp
  attendance: attendance_bool_exp
  end_dt: timestamp_comparison_exp
  event: event_bool_exp
  event_id: Int_comparison_exp
  honorarium_amount: float8_comparison_exp
  id: Int_comparison_exp
  latitude: float8_comparison_exp
  longitude: float8_comparison_exp
  postal: String_comparison_exp
  room_number: String_comparison_exp
  start_dt: timestamp_comparison_exp
  status: String_comparison_exp
  volunteer: volunteer_bool_exp
  volunteer_assignment_opt_ins: volunteer_assignment_opt_in_bool_exp
  volunteer_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"assignment\""
input assignment_inc_input {
  event_id: Int
  honorarium_amount: float8
  id: Int
  latitude: float8
  longitude: float8
  volunteer_id: Int
}

"input type for inserting data into table \"assignment\""
input assignment_insert_input {
  address_line_one: String
  address_line_two: String
  attendance: attendance_obj_rel_insert_input
  end_dt: timestamp
  event: event_obj_rel_insert_input
  event_id: Int
  honorarium_amount: float8
  id: Int
  latitude: float8
  longitude: float8
  postal: String
  room_number: String
  start_dt: timestamp
  status: String
  volunteer: volunteer_obj_rel_insert_input
  volunteer_assignment_opt_ins: volunteer_assignment_opt_in_arr_rel_insert_input
  volunteer_id: Int
}

"order by max() on columns of table \"assignment\""
input assignment_max_order_by {
  address_line_one: order_by
  address_line_two: order_by
  end_dt: order_by
  event_id: order_by
  honorarium_amount: order_by
  id: order_by
  latitude: order_by
  longitude: order_by
  postal: order_by
  room_number: order_by
  start_dt: order_by
  status: order_by
  volunteer_id: order_by
}

"order by min() on columns of table \"assignment\""
input assignment_min_order_by {
  address_line_one: order_by
  address_line_two: order_by
  end_dt: order_by
  event_id: order_by
  honorarium_amount: order_by
  id: order_by
  latitude: order_by
  longitude: order_by
  postal: order_by
  room_number: order_by
  start_dt: order_by
  status: order_by
  volunteer_id: order_by
}

"input type for inserting object relation for remote table \"assignment\""
input assignment_obj_rel_insert_input {
  data: assignment_insert_input!
  on_conflict: assignment_on_conflict
}

"on conflict condition type for table \"assignment\""
input assignment_on_conflict {
  constraint: assignment_constraint!
  update_columns: [assignment_update_column!]!
  where: assignment_bool_exp
}

"ordering options when selecting data from \"assignment\""
input assignment_order_by {
  address_line_one: order_by
  address_line_two: order_by
  attendance: attendance_order_by
  end_dt: order_by
  event: event_order_by
  event_id: order_by
  honorarium_amount: order_by
  id: order_by
  latitude: order_by
  longitude: order_by
  postal: order_by
  room_number: order_by
  start_dt: order_by
  status: order_by
  volunteer: volunteer_order_by
  volunteer_assignment_opt_ins_aggregate: volunteer_assignment_opt_in_aggregate_order_by
  volunteer_id: order_by
}

"primary key columns input for table: \"assignment\""
input assignment_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"assignment\""
input assignment_set_input {
  address_line_one: String
  address_line_two: String
  end_dt: timestamp
  event_id: Int
  honorarium_amount: float8
  id: Int
  latitude: float8
  longitude: float8
  postal: String
  room_number: String
  start_dt: timestamp
  status: String
  volunteer_id: Int
}

"order by stddev() on columns of table \"assignment\""
input assignment_stddev_order_by {
  event_id: order_by
  honorarium_amount: order_by
  id: order_by
  latitude: order_by
  longitude: order_by
  volunteer_id: order_by
}

"order by stddev_pop() on columns of table \"assignment\""
input assignment_stddev_pop_order_by {
  event_id: order_by
  honorarium_amount: order_by
  id: order_by
  latitude: order_by
  longitude: order_by
  volunteer_id: order_by
}

"order by stddev_samp() on columns of table \"assignment\""
input assignment_stddev_samp_order_by {
  event_id: order_by
  honorarium_amount: order_by
  id: order_by
  latitude: order_by
  longitude: order_by
  volunteer_id: order_by
}

"order by sum() on columns of table \"assignment\""
input assignment_sum_order_by {
  event_id: order_by
  honorarium_amount: order_by
  id: order_by
  latitude: order_by
  longitude: order_by
  volunteer_id: order_by
}

"order by var_pop() on columns of table \"assignment\""
input assignment_var_pop_order_by {
  event_id: order_by
  honorarium_amount: order_by
  id: order_by
  latitude: order_by
  longitude: order_by
  volunteer_id: order_by
}

"order by var_samp() on columns of table \"assignment\""
input assignment_var_samp_order_by {
  event_id: order_by
  honorarium_amount: order_by
  id: order_by
  latitude: order_by
  longitude: order_by
  volunteer_id: order_by
}

"order by variance() on columns of table \"assignment\""
input assignment_variance_order_by {
  event_id: order_by
  honorarium_amount: order_by
  id: order_by
  latitude: order_by
  longitude: order_by
  volunteer_id: order_by
}

"order by aggregate values of table \"attendance\""
input attendance_aggregate_order_by {
  avg: attendance_avg_order_by
  count: order_by
  max: attendance_max_order_by
  min: attendance_min_order_by
  stddev: attendance_stddev_order_by
  stddev_pop: attendance_stddev_pop_order_by
  stddev_samp: attendance_stddev_samp_order_by
  sum: attendance_sum_order_by
  var_pop: attendance_var_pop_order_by
  var_samp: attendance_var_samp_order_by
  variance: attendance_variance_order_by
}

"input type for inserting array relation for remote table \"attendance\""
input attendance_arr_rel_insert_input {
  data: [attendance_insert_input!]!
  on_conflict: attendance_on_conflict
}

"order by avg() on columns of table \"attendance\""
input attendance_avg_order_by {
  assignment_id: order_by
  id: order_by
}

"Boolean expression to filter rows from the table \"attendance\". All fields are combined with a logical 'AND'."
input attendance_bool_exp {
  _and: [attendance_bool_exp]
  _not: attendance_bool_exp
  _or: [attendance_bool_exp]
  assignment: assignment_bool_exp
  assignment_id: Int_comparison_exp
  attended: Boolean_comparison_exp
  dispute_comment: String_comparison_exp
  has_dispute: Boolean_comparison_exp
  id: Int_comparison_exp
}

"input type for incrementing integer column in table \"attendance\""
input attendance_inc_input {
  assignment_id: Int
  id: Int
}

"input type for inserting data into table \"attendance\""
input attendance_insert_input {
  assignment: assignment_obj_rel_insert_input
  assignment_id: Int
  attended: Boolean
  dispute_comment: String
  has_dispute: Boolean
  id: Int
}

"order by max() on columns of table \"attendance\""
input attendance_max_order_by {
  assignment_id: order_by
  dispute_comment: order_by
  id: order_by
}

"order by min() on columns of table \"attendance\""
input attendance_min_order_by {
  assignment_id: order_by
  dispute_comment: order_by
  id: order_by
}

"input type for inserting object relation for remote table \"attendance\""
input attendance_obj_rel_insert_input {
  data: attendance_insert_input!
  on_conflict: attendance_on_conflict
}

"on conflict condition type for table \"attendance\""
input attendance_on_conflict {
  constraint: attendance_constraint!
  update_columns: [attendance_update_column!]!
  where: attendance_bool_exp
}

"ordering options when selecting data from \"attendance\""
input attendance_order_by {
  assignment: assignment_order_by
  assignment_id: order_by
  attended: order_by
  dispute_comment: order_by
  has_dispute: order_by
  id: order_by
}

"primary key columns input for table: \"attendance\""
input attendance_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"attendance\""
input attendance_set_input {
  assignment_id: Int
  attended: Boolean
  dispute_comment: String
  has_dispute: Boolean
  id: Int
}

"order by stddev() on columns of table \"attendance\""
input attendance_stddev_order_by {
  assignment_id: order_by
  id: order_by
}

"order by stddev_pop() on columns of table \"attendance\""
input attendance_stddev_pop_order_by {
  assignment_id: order_by
  id: order_by
}

"order by stddev_samp() on columns of table \"attendance\""
input attendance_stddev_samp_order_by {
  assignment_id: order_by
  id: order_by
}

"order by sum() on columns of table \"attendance\""
input attendance_sum_order_by {
  assignment_id: order_by
  id: order_by
}

"order by var_pop() on columns of table \"attendance\""
input attendance_var_pop_order_by {
  assignment_id: order_by
  id: order_by
}

"order by var_samp() on columns of table \"attendance\""
input attendance_var_samp_order_by {
  assignment_id: order_by
  id: order_by
}

"order by variance() on columns of table \"attendance\""
input attendance_variance_order_by {
  assignment_id: order_by
  id: order_by
}

"expression to compare columns of type bigint. All fields are combined with logical 'AND'."
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"order by aggregate values of table \"blacklist\""
input blacklist_aggregate_order_by {
  avg: blacklist_avg_order_by
  count: order_by
  max: blacklist_max_order_by
  min: blacklist_min_order_by
  stddev: blacklist_stddev_order_by
  stddev_pop: blacklist_stddev_pop_order_by
  stddev_samp: blacklist_stddev_samp_order_by
  sum: blacklist_sum_order_by
  var_pop: blacklist_var_pop_order_by
  var_samp: blacklist_var_samp_order_by
  variance: blacklist_variance_order_by
}

"input type for inserting array relation for remote table \"blacklist\""
input blacklist_arr_rel_insert_input {
  data: [blacklist_insert_input!]!
  on_conflict: blacklist_on_conflict
}

"order by avg() on columns of table \"blacklist\""
input blacklist_avg_order_by {
  client_account_id: order_by
  id: order_by
  volunteer_account_id: order_by
}

"Boolean expression to filter rows from the table \"blacklist\". All fields are combined with a logical 'AND'."
input blacklist_bool_exp {
  _and: [blacklist_bool_exp]
  _not: blacklist_bool_exp
  _or: [blacklist_bool_exp]
  client: client_bool_exp
  client_account_id: Int_comparison_exp
  id: Int_comparison_exp
  volunteer: volunteer_bool_exp
  volunteer_account_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"blacklist\""
input blacklist_inc_input {
  client_account_id: Int
  id: Int
  volunteer_account_id: Int
}

"input type for inserting data into table \"blacklist\""
input blacklist_insert_input {
  client: client_obj_rel_insert_input
  client_account_id: Int
  id: Int
  volunteer: volunteer_obj_rel_insert_input
  volunteer_account_id: Int
}

"order by max() on columns of table \"blacklist\""
input blacklist_max_order_by {
  client_account_id: order_by
  id: order_by
  volunteer_account_id: order_by
}

"order by min() on columns of table \"blacklist\""
input blacklist_min_order_by {
  client_account_id: order_by
  id: order_by
  volunteer_account_id: order_by
}

"input type for inserting object relation for remote table \"blacklist\""
input blacklist_obj_rel_insert_input {
  data: blacklist_insert_input!
  on_conflict: blacklist_on_conflict
}

"on conflict condition type for table \"blacklist\""
input blacklist_on_conflict {
  constraint: blacklist_constraint!
  update_columns: [blacklist_update_column!]!
  where: blacklist_bool_exp
}

"ordering options when selecting data from \"blacklist\""
input blacklist_order_by {
  client: client_order_by
  client_account_id: order_by
  id: order_by
  volunteer: volunteer_order_by
  volunteer_account_id: order_by
}

"primary key columns input for table: \"blacklist\""
input blacklist_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"blacklist\""
input blacklist_set_input {
  client_account_id: Int
  id: Int
  volunteer_account_id: Int
}

"order by stddev() on columns of table \"blacklist\""
input blacklist_stddev_order_by {
  client_account_id: order_by
  id: order_by
  volunteer_account_id: order_by
}

"order by stddev_pop() on columns of table \"blacklist\""
input blacklist_stddev_pop_order_by {
  client_account_id: order_by
  id: order_by
  volunteer_account_id: order_by
}

"order by stddev_samp() on columns of table \"blacklist\""
input blacklist_stddev_samp_order_by {
  client_account_id: order_by
  id: order_by
  volunteer_account_id: order_by
}

"order by sum() on columns of table \"blacklist\""
input blacklist_sum_order_by {
  client_account_id: order_by
  id: order_by
  volunteer_account_id: order_by
}

"order by var_pop() on columns of table \"blacklist\""
input blacklist_var_pop_order_by {
  client_account_id: order_by
  id: order_by
  volunteer_account_id: order_by
}

"order by var_samp() on columns of table \"blacklist\""
input blacklist_var_samp_order_by {
  client_account_id: order_by
  id: order_by
  volunteer_account_id: order_by
}

"order by variance() on columns of table \"blacklist\""
input blacklist_variance_order_by {
  client_account_id: order_by
  id: order_by
  volunteer_account_id: order_by
}

"order by aggregate values of table \"client\""
input client_aggregate_order_by {
  avg: client_avg_order_by
  count: order_by
  max: client_max_order_by
  min: client_min_order_by
  stddev: client_stddev_order_by
  stddev_pop: client_stddev_pop_order_by
  stddev_samp: client_stddev_samp_order_by
  sum: client_sum_order_by
  var_pop: client_var_pop_order_by
  var_samp: client_var_samp_order_by
  variance: client_variance_order_by
}

"input type for inserting array relation for remote table \"client\""
input client_arr_rel_insert_input {
  data: [client_insert_input!]!
  on_conflict: client_on_conflict
}

"order by avg() on columns of table \"client\""
input client_avg_order_by {
  account_id: order_by
  id: order_by
  quotation_id: order_by
  service_requestor_id: order_by
}

"Boolean expression to filter rows from the table \"client\". All fields are combined with a logical 'AND'."
input client_bool_exp {
  _and: [client_bool_exp]
  _not: client_bool_exp
  _or: [client_bool_exp]
  account: account_bool_exp
  account_id: Int_comparison_exp
  additional_notes: String_comparison_exp
  blacklists: blacklist_bool_exp
  designation: String_comparison_exp
  events: event_bool_exp
  id: Int_comparison_exp
  organisation: String_comparison_exp
  preferred_comm_mode: String_comparison_exp
  quotation: quotation_bool_exp
  quotation_id: Int_comparison_exp
  service_requestor: service_requestor_bool_exp
  service_requestor_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"client\""
input client_inc_input {
  account_id: Int
  id: Int
  quotation_id: Int
  service_requestor_id: Int
}

"input type for inserting data into table \"client\""
input client_insert_input {
  account: account_obj_rel_insert_input
  account_id: Int
  additional_notes: String
  blacklists: blacklist_arr_rel_insert_input
  designation: String
  events: event_arr_rel_insert_input
  id: Int
  organisation: String
  preferred_comm_mode: String
  quotation: quotation_obj_rel_insert_input
  quotation_id: Int
  service_requestor: service_requestor_obj_rel_insert_input
  service_requestor_id: Int
}

"order by max() on columns of table \"client\""
input client_max_order_by {
  account_id: order_by
  additional_notes: order_by
  designation: order_by
  id: order_by
  organisation: order_by
  preferred_comm_mode: order_by
  quotation_id: order_by
  service_requestor_id: order_by
}

"order by min() on columns of table \"client\""
input client_min_order_by {
  account_id: order_by
  additional_notes: order_by
  designation: order_by
  id: order_by
  organisation: order_by
  preferred_comm_mode: order_by
  quotation_id: order_by
  service_requestor_id: order_by
}

"input type for inserting object relation for remote table \"client\""
input client_obj_rel_insert_input {
  data: client_insert_input!
  on_conflict: client_on_conflict
}

"on conflict condition type for table \"client\""
input client_on_conflict {
  constraint: client_constraint!
  update_columns: [client_update_column!]!
  where: client_bool_exp
}

"ordering options when selecting data from \"client\""
input client_order_by {
  account: account_order_by
  account_id: order_by
  additional_notes: order_by
  blacklists_aggregate: blacklist_aggregate_order_by
  designation: order_by
  events_aggregate: event_aggregate_order_by
  id: order_by
  organisation: order_by
  preferred_comm_mode: order_by
  quotation: quotation_order_by
  quotation_id: order_by
  service_requestor: service_requestor_order_by
  service_requestor_id: order_by
}

"primary key columns input for table: \"client\""
input client_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"client\""
input client_set_input {
  account_id: Int
  additional_notes: String
  designation: String
  id: Int
  organisation: String
  preferred_comm_mode: String
  quotation_id: Int
  service_requestor_id: Int
}

"order by stddev() on columns of table \"client\""
input client_stddev_order_by {
  account_id: order_by
  id: order_by
  quotation_id: order_by
  service_requestor_id: order_by
}

"order by stddev_pop() on columns of table \"client\""
input client_stddev_pop_order_by {
  account_id: order_by
  id: order_by
  quotation_id: order_by
  service_requestor_id: order_by
}

"order by stddev_samp() on columns of table \"client\""
input client_stddev_samp_order_by {
  account_id: order_by
  id: order_by
  quotation_id: order_by
  service_requestor_id: order_by
}

"order by sum() on columns of table \"client\""
input client_sum_order_by {
  account_id: order_by
  id: order_by
  quotation_id: order_by
  service_requestor_id: order_by
}

"order by var_pop() on columns of table \"client\""
input client_var_pop_order_by {
  account_id: order_by
  id: order_by
  quotation_id: order_by
  service_requestor_id: order_by
}

"order by var_samp() on columns of table \"client\""
input client_var_samp_order_by {
  account_id: order_by
  id: order_by
  quotation_id: order_by
  service_requestor_id: order_by
}

"order by variance() on columns of table \"client\""
input client_variance_order_by {
  account_id: order_by
  id: order_by
  quotation_id: order_by
  service_requestor_id: order_by
}

"order by aggregate values of table \"email_information\""
input email_information_aggregate_order_by {
  avg: email_information_avg_order_by
  count: order_by
  max: email_information_max_order_by
  min: email_information_min_order_by
  stddev: email_information_stddev_order_by
  stddev_pop: email_information_stddev_pop_order_by
  stddev_samp: email_information_stddev_samp_order_by
  sum: email_information_sum_order_by
  var_pop: email_information_var_pop_order_by
  var_samp: email_information_var_samp_order_by
  variance: email_information_variance_order_by
}

"input type for inserting array relation for remote table \"email_information\""
input email_information_arr_rel_insert_input {
  data: [email_information_insert_input!]!
  on_conflict: email_information_on_conflict
}

"order by avg() on columns of table \"email_information\""
input email_information_avg_order_by {
  id: order_by
  notification_setting_id: order_by
}

"Boolean expression to filter rows from the table \"email_information\". All fields are combined with a logical 'AND'."
input email_information_bool_exp {
  _and: [email_information_bool_exp]
  _not: email_information_bool_exp
  _or: [email_information_bool_exp]
  id: Int_comparison_exp
  notification_setting: notification_setting_bool_exp
  notification_setting_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"email_information\""
input email_information_inc_input {
  id: Int
  notification_setting_id: Int
}

"input type for inserting data into table \"email_information\""
input email_information_insert_input {
  id: Int
  notification_setting: notification_setting_obj_rel_insert_input
  notification_setting_id: Int
}

"order by max() on columns of table \"email_information\""
input email_information_max_order_by {
  id: order_by
  notification_setting_id: order_by
}

"order by min() on columns of table \"email_information\""
input email_information_min_order_by {
  id: order_by
  notification_setting_id: order_by
}

"input type for inserting object relation for remote table \"email_information\""
input email_information_obj_rel_insert_input {
  data: email_information_insert_input!
  on_conflict: email_information_on_conflict
}

"on conflict condition type for table \"email_information\""
input email_information_on_conflict {
  constraint: email_information_constraint!
  update_columns: [email_information_update_column!]!
  where: email_information_bool_exp
}

"ordering options when selecting data from \"email_information\""
input email_information_order_by {
  id: order_by
  notification_setting: notification_setting_order_by
  notification_setting_id: order_by
}

"primary key columns input for table: \"email_information\""
input email_information_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"email_information\""
input email_information_set_input {
  id: Int
  notification_setting_id: Int
}

"order by stddev() on columns of table \"email_information\""
input email_information_stddev_order_by {
  id: order_by
  notification_setting_id: order_by
}

"order by stddev_pop() on columns of table \"email_information\""
input email_information_stddev_pop_order_by {
  id: order_by
  notification_setting_id: order_by
}

"order by stddev_samp() on columns of table \"email_information\""
input email_information_stddev_samp_order_by {
  id: order_by
  notification_setting_id: order_by
}

"order by sum() on columns of table \"email_information\""
input email_information_sum_order_by {
  id: order_by
  notification_setting_id: order_by
}

"order by var_pop() on columns of table \"email_information\""
input email_information_var_pop_order_by {
  id: order_by
  notification_setting_id: order_by
}

"order by var_samp() on columns of table \"email_information\""
input email_information_var_samp_order_by {
  id: order_by
  notification_setting_id: order_by
}

"order by variance() on columns of table \"email_information\""
input email_information_variance_order_by {
  id: order_by
  notification_setting_id: order_by
}

"order by aggregate values of table \"event\""
input event_aggregate_order_by {
  avg: event_avg_order_by
  count: order_by
  max: event_max_order_by
  min: event_min_order_by
  stddev: event_stddev_order_by
  stddev_pop: event_stddev_pop_order_by
  stddev_samp: event_stddev_samp_order_by
  sum: event_sum_order_by
  var_pop: event_var_pop_order_by
  var_samp: event_var_samp_order_by
  variance: event_variance_order_by
}

"input type for inserting array relation for remote table \"event\""
input event_arr_rel_insert_input {
  data: [event_insert_input!]!
  on_conflict: event_on_conflict
}

"order by avg() on columns of table \"event\""
input event_avg_order_by {
  client_id: order_by
  id: order_by
}

"Boolean expression to filter rows from the table \"event\". All fields are combined with a logical 'AND'."
input event_bool_exp {
  _and: [event_bool_exp]
  _not: event_bool_exp
  _or: [event_bool_exp]
  assignments: assignment_bool_exp
  client: client_bool_exp
  client_id: Int_comparison_exp
  created_at: timestamp_comparison_exp
  description: String_comparison_exp
  feedbacks: feedback_bool_exp
  id: Int_comparison_exp
  interpretation_detail: interpretation_details_bool_exp
  interpreter_required: Boolean_comparison_exp
  invoice: invoice_bool_exp
  name: String_comparison_exp
  notetaker_required: Boolean_comparison_exp
  purpose: String_comparison_exp
  updated_at: timestamp_comparison_exp
}

"input type for incrementing integer column in table \"event\""
input event_inc_input {
  client_id: Int
  id: Int
}

"input type for inserting data into table \"event\""
input event_insert_input {
  assignments: assignment_arr_rel_insert_input
  client: client_obj_rel_insert_input
  client_id: Int
  created_at: timestamp
  description: String
  feedbacks: feedback_arr_rel_insert_input
  id: Int
  interpretation_detail: interpretation_details_obj_rel_insert_input
  interpreter_required: Boolean
  invoice: invoice_obj_rel_insert_input
  name: String
  notetaker_required: Boolean
  purpose: String
  updated_at: timestamp
}

"order by max() on columns of table \"event\""
input event_max_order_by {
  client_id: order_by
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  purpose: order_by
  updated_at: order_by
}

"order by min() on columns of table \"event\""
input event_min_order_by {
  client_id: order_by
  created_at: order_by
  description: order_by
  id: order_by
  name: order_by
  purpose: order_by
  updated_at: order_by
}

"input type for inserting object relation for remote table \"event\""
input event_obj_rel_insert_input {
  data: event_insert_input!
  on_conflict: event_on_conflict
}

"on conflict condition type for table \"event\""
input event_on_conflict {
  constraint: event_constraint!
  update_columns: [event_update_column!]!
  where: event_bool_exp
}

"ordering options when selecting data from \"event\""
input event_order_by {
  assignments_aggregate: assignment_aggregate_order_by
  client: client_order_by
  client_id: order_by
  created_at: order_by
  description: order_by
  feedbacks_aggregate: feedback_aggregate_order_by
  id: order_by
  interpretation_detail: interpretation_details_order_by
  interpreter_required: order_by
  invoice: invoice_order_by
  name: order_by
  notetaker_required: order_by
  purpose: order_by
  updated_at: order_by
}

"primary key columns input for table: \"event\""
input event_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"event\""
input event_set_input {
  client_id: Int
  created_at: timestamp
  description: String
  id: Int
  interpreter_required: Boolean
  name: String
  notetaker_required: Boolean
  purpose: String
  updated_at: timestamp
}

"order by stddev() on columns of table \"event\""
input event_stddev_order_by {
  client_id: order_by
  id: order_by
}

"order by stddev_pop() on columns of table \"event\""
input event_stddev_pop_order_by {
  client_id: order_by
  id: order_by
}

"order by stddev_samp() on columns of table \"event\""
input event_stddev_samp_order_by {
  client_id: order_by
  id: order_by
}

"order by sum() on columns of table \"event\""
input event_sum_order_by {
  client_id: order_by
  id: order_by
}

"order by var_pop() on columns of table \"event\""
input event_var_pop_order_by {
  client_id: order_by
  id: order_by
}

"order by var_samp() on columns of table \"event\""
input event_var_samp_order_by {
  client_id: order_by
  id: order_by
}

"order by variance() on columns of table \"event\""
input event_variance_order_by {
  client_id: order_by
  id: order_by
}

"order by aggregate values of table \"feedback\""
input feedback_aggregate_order_by {
  avg: feedback_avg_order_by
  count: order_by
  max: feedback_max_order_by
  min: feedback_min_order_by
  stddev: feedback_stddev_order_by
  stddev_pop: feedback_stddev_pop_order_by
  stddev_samp: feedback_stddev_samp_order_by
  sum: feedback_sum_order_by
  var_pop: feedback_var_pop_order_by
  var_samp: feedback_var_samp_order_by
  variance: feedback_variance_order_by
}

"input type for inserting array relation for remote table \"feedback\""
input feedback_arr_rel_insert_input {
  data: [feedback_insert_input!]!
  on_conflict: feedback_on_conflict
}

"order by avg() on columns of table \"feedback\""
input feedback_avg_order_by {
  event_id: order_by
  feedback_given: order_by
  id: order_by
  volunteer_id: order_by
}

"Boolean expression to filter rows from the table \"feedback\". All fields are combined with a logical 'AND'."
input feedback_bool_exp {
  _and: [feedback_bool_exp]
  _not: feedback_bool_exp
  _or: [feedback_bool_exp]
  confidentiality_privacy_preference: privacy_enum_comparison_exp
  created_at: timestamp_comparison_exp
  event: event_bool_exp
  event_id: Int_comparison_exp
  feedback_given: Int_comparison_exp
  general_feedback: String_comparison_exp
  id: Int_comparison_exp
  live_comments: String_comparison_exp
  live_information_understanding: rating_enum_comparison_exp
  live_interaction: rating_enum_comparison_exp
  notetaker_conduct: rating_enum_comparison_exp
  notetaker_punctual: rating_enum_comparison_exp
  post_session_comments: String_comparison_exp
  post_session_understanding: rating_enum_comparison_exp
  training_privacy_preference: privacy_enum_comparison_exp
  updated_at: timestamp_comparison_exp
  volunteer: volunteer_bool_exp
  volunteer_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"feedback\""
input feedback_inc_input {
  event_id: Int
  feedback_given: Int
  id: Int
  volunteer_id: Int
}

"input type for inserting data into table \"feedback\""
input feedback_insert_input {
  confidentiality_privacy_preference: privacy_enum
  created_at: timestamp
  event: event_obj_rel_insert_input
  event_id: Int
  feedback_given: Int
  general_feedback: String
  id: Int
  live_comments: String
  live_information_understanding: rating_enum
  live_interaction: rating_enum
  notetaker_conduct: rating_enum
  notetaker_punctual: rating_enum
  post_session_comments: String
  post_session_understanding: rating_enum
  training_privacy_preference: privacy_enum
  updated_at: timestamp
  volunteer: volunteer_obj_rel_insert_input
  volunteer_id: Int
}

"order by max() on columns of table \"feedback\""
input feedback_max_order_by {
  created_at: order_by
  event_id: order_by
  feedback_given: order_by
  general_feedback: order_by
  id: order_by
  live_comments: order_by
  post_session_comments: order_by
  updated_at: order_by
  volunteer_id: order_by
}

"order by min() on columns of table \"feedback\""
input feedback_min_order_by {
  created_at: order_by
  event_id: order_by
  feedback_given: order_by
  general_feedback: order_by
  id: order_by
  live_comments: order_by
  post_session_comments: order_by
  updated_at: order_by
  volunteer_id: order_by
}

"input type for inserting object relation for remote table \"feedback\""
input feedback_obj_rel_insert_input {
  data: feedback_insert_input!
  on_conflict: feedback_on_conflict
}

"on conflict condition type for table \"feedback\""
input feedback_on_conflict {
  constraint: feedback_constraint!
  update_columns: [feedback_update_column!]!
  where: feedback_bool_exp
}

"ordering options when selecting data from \"feedback\""
input feedback_order_by {
  confidentiality_privacy_preference: order_by
  created_at: order_by
  event: event_order_by
  event_id: order_by
  feedback_given: order_by
  general_feedback: order_by
  id: order_by
  live_comments: order_by
  live_information_understanding: order_by
  live_interaction: order_by
  notetaker_conduct: order_by
  notetaker_punctual: order_by
  post_session_comments: order_by
  post_session_understanding: order_by
  training_privacy_preference: order_by
  updated_at: order_by
  volunteer: volunteer_order_by
  volunteer_id: order_by
}

"input type for updating data in table \"feedback\""
input feedback_set_input {
  confidentiality_privacy_preference: privacy_enum
  created_at: timestamp
  event_id: Int
  feedback_given: Int
  general_feedback: String
  id: Int
  live_comments: String
  live_information_understanding: rating_enum
  live_interaction: rating_enum
  notetaker_conduct: rating_enum
  notetaker_punctual: rating_enum
  post_session_comments: String
  post_session_understanding: rating_enum
  training_privacy_preference: privacy_enum
  updated_at: timestamp
  volunteer_id: Int
}

"order by stddev() on columns of table \"feedback\""
input feedback_stddev_order_by {
  event_id: order_by
  feedback_given: order_by
  id: order_by
  volunteer_id: order_by
}

"order by stddev_pop() on columns of table \"feedback\""
input feedback_stddev_pop_order_by {
  event_id: order_by
  feedback_given: order_by
  id: order_by
  volunteer_id: order_by
}

"order by stddev_samp() on columns of table \"feedback\""
input feedback_stddev_samp_order_by {
  event_id: order_by
  feedback_given: order_by
  id: order_by
  volunteer_id: order_by
}

"order by sum() on columns of table \"feedback\""
input feedback_sum_order_by {
  event_id: order_by
  feedback_given: order_by
  id: order_by
  volunteer_id: order_by
}

"order by var_pop() on columns of table \"feedback\""
input feedback_var_pop_order_by {
  event_id: order_by
  feedback_given: order_by
  id: order_by
  volunteer_id: order_by
}

"order by var_samp() on columns of table \"feedback\""
input feedback_var_samp_order_by {
  event_id: order_by
  feedback_given: order_by
  id: order_by
  volunteer_id: order_by
}

"order by variance() on columns of table \"feedback\""
input feedback_variance_order_by {
  event_id: order_by
  feedback_given: order_by
  id: order_by
  volunteer_id: order_by
}

"expression to compare columns of type float8. All fields are combined with logical 'AND'."
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

"order by aggregate values of table \"interpretation_details\""
input interpretation_details_aggregate_order_by {
  avg: interpretation_details_avg_order_by
  count: order_by
  max: interpretation_details_max_order_by
  min: interpretation_details_min_order_by
  stddev: interpretation_details_stddev_order_by
  stddev_pop: interpretation_details_stddev_pop_order_by
  stddev_samp: interpretation_details_stddev_samp_order_by
  sum: interpretation_details_sum_order_by
  var_pop: interpretation_details_var_pop_order_by
  var_samp: interpretation_details_var_samp_order_by
  variance: interpretation_details_variance_order_by
}

"input type for inserting array relation for remote table \"interpretation_details\""
input interpretation_details_arr_rel_insert_input {
  data: [interpretation_details_insert_input!]!
  on_conflict: interpretation_details_on_conflict
}

"order by avg() on columns of table \"interpretation_details\""
input interpretation_details_avg_order_by {
  event_id: order_by
  id: order_by
  number_of_deaf: order_by
  number_of_hearing: order_by
}

"Boolean expression to filter rows from the table \"interpretation_details\". All fields are combined with a logical 'AND'."
input interpretation_details_bool_exp {
  _and: [interpretation_details_bool_exp]
  _not: interpretation_details_bool_exp
  _or: [interpretation_details_bool_exp]
  allow_trainee_interpreters: Boolean_comparison_exp
  event: event_bool_exp
  event_id: Int_comparison_exp
  filming_interpreters: Boolean_comparison_exp
  id: Int_comparison_exp
  number_of_deaf: Int_comparison_exp
  number_of_hearing: Int_comparison_exp
  sign_system: String_comparison_exp
}

"input type for incrementing integer column in table \"interpretation_details\""
input interpretation_details_inc_input {
  event_id: Int
  id: Int
  number_of_deaf: Int
  number_of_hearing: Int
}

"input type for inserting data into table \"interpretation_details\""
input interpretation_details_insert_input {
  allow_trainee_interpreters: Boolean
  event: event_obj_rel_insert_input
  event_id: Int
  filming_interpreters: Boolean
  id: Int
  number_of_deaf: Int
  number_of_hearing: Int
  sign_system: String
}

"order by max() on columns of table \"interpretation_details\""
input interpretation_details_max_order_by {
  event_id: order_by
  id: order_by
  number_of_deaf: order_by
  number_of_hearing: order_by
  sign_system: order_by
}

"order by min() on columns of table \"interpretation_details\""
input interpretation_details_min_order_by {
  event_id: order_by
  id: order_by
  number_of_deaf: order_by
  number_of_hearing: order_by
  sign_system: order_by
}

"input type for inserting object relation for remote table \"interpretation_details\""
input interpretation_details_obj_rel_insert_input {
  data: interpretation_details_insert_input!
  on_conflict: interpretation_details_on_conflict
}

"on conflict condition type for table \"interpretation_details\""
input interpretation_details_on_conflict {
  constraint: interpretation_details_constraint!
  update_columns: [interpretation_details_update_column!]!
  where: interpretation_details_bool_exp
}

"ordering options when selecting data from \"interpretation_details\""
input interpretation_details_order_by {
  allow_trainee_interpreters: order_by
  event: event_order_by
  event_id: order_by
  filming_interpreters: order_by
  id: order_by
  number_of_deaf: order_by
  number_of_hearing: order_by
  sign_system: order_by
}

"input type for updating data in table \"interpretation_details\""
input interpretation_details_set_input {
  allow_trainee_interpreters: Boolean
  event_id: Int
  filming_interpreters: Boolean
  id: Int
  number_of_deaf: Int
  number_of_hearing: Int
  sign_system: String
}

"order by stddev() on columns of table \"interpretation_details\""
input interpretation_details_stddev_order_by {
  event_id: order_by
  id: order_by
  number_of_deaf: order_by
  number_of_hearing: order_by
}

"order by stddev_pop() on columns of table \"interpretation_details\""
input interpretation_details_stddev_pop_order_by {
  event_id: order_by
  id: order_by
  number_of_deaf: order_by
  number_of_hearing: order_by
}

"order by stddev_samp() on columns of table \"interpretation_details\""
input interpretation_details_stddev_samp_order_by {
  event_id: order_by
  id: order_by
  number_of_deaf: order_by
  number_of_hearing: order_by
}

"order by sum() on columns of table \"interpretation_details\""
input interpretation_details_sum_order_by {
  event_id: order_by
  id: order_by
  number_of_deaf: order_by
  number_of_hearing: order_by
}

"order by var_pop() on columns of table \"interpretation_details\""
input interpretation_details_var_pop_order_by {
  event_id: order_by
  id: order_by
  number_of_deaf: order_by
  number_of_hearing: order_by
}

"order by var_samp() on columns of table \"interpretation_details\""
input interpretation_details_var_samp_order_by {
  event_id: order_by
  id: order_by
  number_of_deaf: order_by
  number_of_hearing: order_by
}

"order by variance() on columns of table \"interpretation_details\""
input interpretation_details_variance_order_by {
  event_id: order_by
  id: order_by
  number_of_deaf: order_by
  number_of_hearing: order_by
}

"order by aggregate values of table \"invoice\""
input invoice_aggregate_order_by {
  avg: invoice_avg_order_by
  count: order_by
  max: invoice_max_order_by
  min: invoice_min_order_by
  stddev: invoice_stddev_order_by
  stddev_pop: invoice_stddev_pop_order_by
  stddev_samp: invoice_stddev_samp_order_by
  sum: invoice_sum_order_by
  var_pop: invoice_var_pop_order_by
  var_samp: invoice_var_samp_order_by
  variance: invoice_variance_order_by
}

"input type for inserting array relation for remote table \"invoice\""
input invoice_arr_rel_insert_input {
  data: [invoice_insert_input!]!
  on_conflict: invoice_on_conflict
}

"order by avg() on columns of table \"invoice\""
input invoice_avg_order_by {
  amount: order_by
  event_id: order_by
  id: order_by
}

"Boolean expression to filter rows from the table \"invoice\". All fields are combined with a logical 'AND'."
input invoice_bool_exp {
  _and: [invoice_bool_exp]
  _not: invoice_bool_exp
  _or: [invoice_bool_exp]
  amount: numeric_comparison_exp
  created_at: timestamp_comparison_exp
  event: event_bool_exp
  event_id: Int_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  updated_at: timestamp_comparison_exp
}

"input type for incrementing integer column in table \"invoice\""
input invoice_inc_input {
  amount: numeric
  event_id: Int
  id: Int
}

"input type for inserting data into table \"invoice\""
input invoice_insert_input {
  amount: numeric
  created_at: timestamp
  event: event_obj_rel_insert_input
  event_id: Int
  id: Int
  name: String
  updated_at: timestamp
}

"order by max() on columns of table \"invoice\""
input invoice_max_order_by {
  amount: order_by
  created_at: order_by
  event_id: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"order by min() on columns of table \"invoice\""
input invoice_min_order_by {
  amount: order_by
  created_at: order_by
  event_id: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"input type for inserting object relation for remote table \"invoice\""
input invoice_obj_rel_insert_input {
  data: invoice_insert_input!
  on_conflict: invoice_on_conflict
}

"on conflict condition type for table \"invoice\""
input invoice_on_conflict {
  constraint: invoice_constraint!
  update_columns: [invoice_update_column!]!
  where: invoice_bool_exp
}

"ordering options when selecting data from \"invoice\""
input invoice_order_by {
  amount: order_by
  created_at: order_by
  event: event_order_by
  event_id: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

"primary key columns input for table: \"invoice\""
input invoice_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"invoice\""
input invoice_set_input {
  amount: numeric
  created_at: timestamp
  event_id: Int
  id: Int
  name: String
  updated_at: timestamp
}

"order by stddev() on columns of table \"invoice\""
input invoice_stddev_order_by {
  amount: order_by
  event_id: order_by
  id: order_by
}

"order by stddev_pop() on columns of table \"invoice\""
input invoice_stddev_pop_order_by {
  amount: order_by
  event_id: order_by
  id: order_by
}

"order by stddev_samp() on columns of table \"invoice\""
input invoice_stddev_samp_order_by {
  amount: order_by
  event_id: order_by
  id: order_by
}

"order by sum() on columns of table \"invoice\""
input invoice_sum_order_by {
  amount: order_by
  event_id: order_by
  id: order_by
}

"order by var_pop() on columns of table \"invoice\""
input invoice_var_pop_order_by {
  amount: order_by
  event_id: order_by
  id: order_by
}

"order by var_samp() on columns of table \"invoice\""
input invoice_var_samp_order_by {
  amount: order_by
  event_id: order_by
  id: order_by
}

"order by variance() on columns of table \"invoice\""
input invoice_variance_order_by {
  amount: order_by
  event_id: order_by
  id: order_by
}

"order by aggregate values of table \"membership\""
input membership_aggregate_order_by {
  avg: membership_avg_order_by
  count: order_by
  max: membership_max_order_by
  min: membership_min_order_by
  stddev: membership_stddev_order_by
  stddev_pop: membership_stddev_pop_order_by
  stddev_samp: membership_stddev_samp_order_by
  sum: membership_sum_order_by
  var_pop: membership_var_pop_order_by
  var_samp: membership_var_samp_order_by
  variance: membership_variance_order_by
}

"input type for inserting array relation for remote table \"membership\""
input membership_arr_rel_insert_input {
  data: [membership_insert_input!]!
  on_conflict: membership_on_conflict
}

"order by avg() on columns of table \"membership\""
input membership_avg_order_by {
  account_id: order_by
  free_sessions_remaining: order_by
  id: order_by
  membership_type_id: order_by
}

"Boolean expression to filter rows from the table \"membership\". All fields are combined with a logical 'AND'."
input membership_bool_exp {
  _and: [membership_bool_exp]
  _not: membership_bool_exp
  _or: [membership_bool_exp]
  account: account_bool_exp
  account_id: Int_comparison_exp
  created_at: timestamp_comparison_exp
  free_sessions_remaining: numeric_comparison_exp
  id: Int_comparison_exp
  membership_renewals: membership_renewals_bool_exp
  membership_type: membership_type_bool_exp
  membership_type_id: Int_comparison_exp
  service_requestors: service_requestor_bool_exp
  status: String_comparison_exp
  updated_at: timestamp_comparison_exp
}

"input type for incrementing integer column in table \"membership\""
input membership_inc_input {
  account_id: Int
  free_sessions_remaining: numeric
  id: Int
  membership_type_id: Int
}

"input type for inserting data into table \"membership\""
input membership_insert_input {
  account: account_obj_rel_insert_input
  account_id: Int
  created_at: timestamp
  free_sessions_remaining: numeric
  id: Int
  membership_renewals: membership_renewals_arr_rel_insert_input
  membership_type: membership_type_obj_rel_insert_input
  membership_type_id: Int
  service_requestors: service_requestor_arr_rel_insert_input
  status: String
  updated_at: timestamp
}

"order by max() on columns of table \"membership\""
input membership_max_order_by {
  account_id: order_by
  created_at: order_by
  free_sessions_remaining: order_by
  id: order_by
  membership_type_id: order_by
  status: order_by
  updated_at: order_by
}

"order by min() on columns of table \"membership\""
input membership_min_order_by {
  account_id: order_by
  created_at: order_by
  free_sessions_remaining: order_by
  id: order_by
  membership_type_id: order_by
  status: order_by
  updated_at: order_by
}

"input type for inserting object relation for remote table \"membership\""
input membership_obj_rel_insert_input {
  data: membership_insert_input!
  on_conflict: membership_on_conflict
}

"on conflict condition type for table \"membership\""
input membership_on_conflict {
  constraint: membership_constraint!
  update_columns: [membership_update_column!]!
  where: membership_bool_exp
}

"ordering options when selecting data from \"membership\""
input membership_order_by {
  account: account_order_by
  account_id: order_by
  created_at: order_by
  free_sessions_remaining: order_by
  id: order_by
  membership_renewals_aggregate: membership_renewals_aggregate_order_by
  membership_type: membership_type_order_by
  membership_type_id: order_by
  service_requestors_aggregate: service_requestor_aggregate_order_by
  status: order_by
  updated_at: order_by
}

"primary key columns input for table: \"membership\""
input membership_pk_columns_input {
  id: Int!
}

"order by aggregate values of table \"membership_renewals\""
input membership_renewals_aggregate_order_by {
  avg: membership_renewals_avg_order_by
  count: order_by
  max: membership_renewals_max_order_by
  min: membership_renewals_min_order_by
  stddev: membership_renewals_stddev_order_by
  stddev_pop: membership_renewals_stddev_pop_order_by
  stddev_samp: membership_renewals_stddev_samp_order_by
  sum: membership_renewals_sum_order_by
  var_pop: membership_renewals_var_pop_order_by
  var_samp: membership_renewals_var_samp_order_by
  variance: membership_renewals_variance_order_by
}

"input type for inserting array relation for remote table \"membership_renewals\""
input membership_renewals_arr_rel_insert_input {
  data: [membership_renewals_insert_input!]!
  on_conflict: membership_renewals_on_conflict
}

"order by avg() on columns of table \"membership_renewals\""
input membership_renewals_avg_order_by {
  id: order_by
  membership_id: order_by
}

"Boolean expression to filter rows from the table \"membership_renewals\". All fields are combined with a logical 'AND'."
input membership_renewals_bool_exp {
  _and: [membership_renewals_bool_exp]
  _not: membership_renewals_bool_exp
  _or: [membership_renewals_bool_exp]
  created_at: timestamp_comparison_exp
  id: Int_comparison_exp
  membership: membership_bool_exp
  membership_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"membership_renewals\""
input membership_renewals_inc_input {
  id: Int
  membership_id: Int
}

"input type for inserting data into table \"membership_renewals\""
input membership_renewals_insert_input {
  created_at: timestamp
  id: Int
  membership: membership_obj_rel_insert_input
  membership_id: Int
}

"order by max() on columns of table \"membership_renewals\""
input membership_renewals_max_order_by {
  created_at: order_by
  id: order_by
  membership_id: order_by
}

"order by min() on columns of table \"membership_renewals\""
input membership_renewals_min_order_by {
  created_at: order_by
  id: order_by
  membership_id: order_by
}

"input type for inserting object relation for remote table \"membership_renewals\""
input membership_renewals_obj_rel_insert_input {
  data: membership_renewals_insert_input!
  on_conflict: membership_renewals_on_conflict
}

"on conflict condition type for table \"membership_renewals\""
input membership_renewals_on_conflict {
  constraint: membership_renewals_constraint!
  update_columns: [membership_renewals_update_column!]!
  where: membership_renewals_bool_exp
}

"ordering options when selecting data from \"membership_renewals\""
input membership_renewals_order_by {
  created_at: order_by
  id: order_by
  membership: membership_order_by
  membership_id: order_by
}

"primary key columns input for table: \"membership_renewals\""
input membership_renewals_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"membership_renewals\""
input membership_renewals_set_input {
  created_at: timestamp
  id: Int
  membership_id: Int
}

"order by stddev() on columns of table \"membership_renewals\""
input membership_renewals_stddev_order_by {
  id: order_by
  membership_id: order_by
}

"order by stddev_pop() on columns of table \"membership_renewals\""
input membership_renewals_stddev_pop_order_by {
  id: order_by
  membership_id: order_by
}

"order by stddev_samp() on columns of table \"membership_renewals\""
input membership_renewals_stddev_samp_order_by {
  id: order_by
  membership_id: order_by
}

"order by sum() on columns of table \"membership_renewals\""
input membership_renewals_sum_order_by {
  id: order_by
  membership_id: order_by
}

"order by var_pop() on columns of table \"membership_renewals\""
input membership_renewals_var_pop_order_by {
  id: order_by
  membership_id: order_by
}

"order by var_samp() on columns of table \"membership_renewals\""
input membership_renewals_var_samp_order_by {
  id: order_by
  membership_id: order_by
}

"order by variance() on columns of table \"membership_renewals\""
input membership_renewals_variance_order_by {
  id: order_by
  membership_id: order_by
}

"input type for updating data in table \"membership\""
input membership_set_input {
  account_id: Int
  created_at: timestamp
  free_sessions_remaining: numeric
  id: Int
  membership_type_id: Int
  status: String
  updated_at: timestamp
}

"order by stddev() on columns of table \"membership\""
input membership_stddev_order_by {
  account_id: order_by
  free_sessions_remaining: order_by
  id: order_by
  membership_type_id: order_by
}

"order by stddev_pop() on columns of table \"membership\""
input membership_stddev_pop_order_by {
  account_id: order_by
  free_sessions_remaining: order_by
  id: order_by
  membership_type_id: order_by
}

"order by stddev_samp() on columns of table \"membership\""
input membership_stddev_samp_order_by {
  account_id: order_by
  free_sessions_remaining: order_by
  id: order_by
  membership_type_id: order_by
}

"order by sum() on columns of table \"membership\""
input membership_sum_order_by {
  account_id: order_by
  free_sessions_remaining: order_by
  id: order_by
  membership_type_id: order_by
}

"order by aggregate values of table \"membership_type\""
input membership_type_aggregate_order_by {
  avg: membership_type_avg_order_by
  count: order_by
  max: membership_type_max_order_by
  min: membership_type_min_order_by
  stddev: membership_type_stddev_order_by
  stddev_pop: membership_type_stddev_pop_order_by
  stddev_samp: membership_type_stddev_samp_order_by
  sum: membership_type_sum_order_by
  var_pop: membership_type_var_pop_order_by
  var_samp: membership_type_var_samp_order_by
  variance: membership_type_variance_order_by
}

"input type for inserting array relation for remote table \"membership_type\""
input membership_type_arr_rel_insert_input {
  data: [membership_type_insert_input!]!
  on_conflict: membership_type_on_conflict
}

"order by avg() on columns of table \"membership_type\""
input membership_type_avg_order_by {
  cost: order_by
  duration_in_days: order_by
  id: order_by
}

"Boolean expression to filter rows from the table \"membership_type\". All fields are combined with a logical 'AND'."
input membership_type_bool_exp {
  _and: [membership_type_bool_exp]
  _not: membership_type_bool_exp
  _or: [membership_type_bool_exp]
  cost: numeric_comparison_exp
  description: String_comparison_exp
  duration_in_days: Int_comparison_exp
  id: Int_comparison_exp
  memberships: membership_bool_exp
  name: String_comparison_exp
}

"input type for incrementing integer column in table \"membership_type\""
input membership_type_inc_input {
  cost: numeric
  duration_in_days: Int
  id: Int
}

"input type for inserting data into table \"membership_type\""
input membership_type_insert_input {
  cost: numeric
  description: String
  duration_in_days: Int
  id: Int
  memberships: membership_arr_rel_insert_input
  name: String
}

"order by max() on columns of table \"membership_type\""
input membership_type_max_order_by {
  cost: order_by
  description: order_by
  duration_in_days: order_by
  id: order_by
  name: order_by
}

"order by min() on columns of table \"membership_type\""
input membership_type_min_order_by {
  cost: order_by
  description: order_by
  duration_in_days: order_by
  id: order_by
  name: order_by
}

"input type for inserting object relation for remote table \"membership_type\""
input membership_type_obj_rel_insert_input {
  data: membership_type_insert_input!
  on_conflict: membership_type_on_conflict
}

"on conflict condition type for table \"membership_type\""
input membership_type_on_conflict {
  constraint: membership_type_constraint!
  update_columns: [membership_type_update_column!]!
  where: membership_type_bool_exp
}

"ordering options when selecting data from \"membership_type\""
input membership_type_order_by {
  cost: order_by
  description: order_by
  duration_in_days: order_by
  id: order_by
  memberships_aggregate: membership_aggregate_order_by
  name: order_by
}

"primary key columns input for table: \"membership_type\""
input membership_type_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"membership_type\""
input membership_type_set_input {
  cost: numeric
  description: String
  duration_in_days: Int
  id: Int
  name: String
}

"order by stddev() on columns of table \"membership_type\""
input membership_type_stddev_order_by {
  cost: order_by
  duration_in_days: order_by
  id: order_by
}

"order by stddev_pop() on columns of table \"membership_type\""
input membership_type_stddev_pop_order_by {
  cost: order_by
  duration_in_days: order_by
  id: order_by
}

"order by stddev_samp() on columns of table \"membership_type\""
input membership_type_stddev_samp_order_by {
  cost: order_by
  duration_in_days: order_by
  id: order_by
}

"order by sum() on columns of table \"membership_type\""
input membership_type_sum_order_by {
  cost: order_by
  duration_in_days: order_by
  id: order_by
}

"order by var_pop() on columns of table \"membership_type\""
input membership_type_var_pop_order_by {
  cost: order_by
  duration_in_days: order_by
  id: order_by
}

"order by var_samp() on columns of table \"membership_type\""
input membership_type_var_samp_order_by {
  cost: order_by
  duration_in_days: order_by
  id: order_by
}

"order by variance() on columns of table \"membership_type\""
input membership_type_variance_order_by {
  cost: order_by
  duration_in_days: order_by
  id: order_by
}

"order by var_pop() on columns of table \"membership\""
input membership_var_pop_order_by {
  account_id: order_by
  free_sessions_remaining: order_by
  id: order_by
  membership_type_id: order_by
}

"order by var_samp() on columns of table \"membership\""
input membership_var_samp_order_by {
  account_id: order_by
  free_sessions_remaining: order_by
  id: order_by
  membership_type_id: order_by
}

"order by variance() on columns of table \"membership\""
input membership_variance_order_by {
  account_id: order_by
  free_sessions_remaining: order_by
  id: order_by
  membership_type_id: order_by
}

"order by aggregate values of table \"notification_setting\""
input notification_setting_aggregate_order_by {
  avg: notification_setting_avg_order_by
  count: order_by
  max: notification_setting_max_order_by
  min: notification_setting_min_order_by
  stddev: notification_setting_stddev_order_by
  stddev_pop: notification_setting_stddev_pop_order_by
  stddev_samp: notification_setting_stddev_samp_order_by
  sum: notification_setting_sum_order_by
  var_pop: notification_setting_var_pop_order_by
  var_samp: notification_setting_var_samp_order_by
  variance: notification_setting_variance_order_by
}

"input type for inserting array relation for remote table \"notification_setting\""
input notification_setting_arr_rel_insert_input {
  data: [notification_setting_insert_input!]!
  on_conflict: notification_setting_on_conflict
}

"order by avg() on columns of table \"notification_setting\""
input notification_setting_avg_order_by {
  account_id: order_by
  id: order_by
}

"Boolean expression to filter rows from the table \"notification_setting\". All fields are combined with a logical 'AND'."
input notification_setting_bool_exp {
  _and: [notification_setting_bool_exp]
  _not: notification_setting_bool_exp
  _or: [notification_setting_bool_exp]
  account: account_bool_exp
  account_id: Int_comparison_exp
  client_matched: Boolean_comparison_exp
  client_unmatched: Boolean_comparison_exp
  email_information: email_information_bool_exp
  id: Int_comparison_exp
  telegram_information: telegram_information_bool_exp
  volunteer_matched: Boolean_comparison_exp
  volunteer_new: Boolean_comparison_exp
  volunteer_periodic: Boolean_comparison_exp
  volunteer_urgent: Boolean_comparison_exp
}

"input type for incrementing integer column in table \"notification_setting\""
input notification_setting_inc_input {
  account_id: Int
  id: Int
}

"input type for inserting data into table \"notification_setting\""
input notification_setting_insert_input {
  account: account_obj_rel_insert_input
  account_id: Int
  client_matched: Boolean
  client_unmatched: Boolean
  email_information: email_information_obj_rel_insert_input
  id: Int
  telegram_information: telegram_information_obj_rel_insert_input
  volunteer_matched: Boolean
  volunteer_new: Boolean
  volunteer_periodic: Boolean
  volunteer_urgent: Boolean
}

"order by max() on columns of table \"notification_setting\""
input notification_setting_max_order_by {
  account_id: order_by
  id: order_by
}

"order by min() on columns of table \"notification_setting\""
input notification_setting_min_order_by {
  account_id: order_by
  id: order_by
}

"input type for inserting object relation for remote table \"notification_setting\""
input notification_setting_obj_rel_insert_input {
  data: notification_setting_insert_input!
  on_conflict: notification_setting_on_conflict
}

"on conflict condition type for table \"notification_setting\""
input notification_setting_on_conflict {
  constraint: notification_setting_constraint!
  update_columns: [notification_setting_update_column!]!
  where: notification_setting_bool_exp
}

"ordering options when selecting data from \"notification_setting\""
input notification_setting_order_by {
  account: account_order_by
  account_id: order_by
  client_matched: order_by
  client_unmatched: order_by
  email_information: email_information_order_by
  id: order_by
  telegram_information: telegram_information_order_by
  volunteer_matched: order_by
  volunteer_new: order_by
  volunteer_periodic: order_by
  volunteer_urgent: order_by
}

"primary key columns input for table: \"notification_setting\""
input notification_setting_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"notification_setting\""
input notification_setting_set_input {
  account_id: Int
  client_matched: Boolean
  client_unmatched: Boolean
  id: Int
  volunteer_matched: Boolean
  volunteer_new: Boolean
  volunteer_periodic: Boolean
  volunteer_urgent: Boolean
}

"order by stddev() on columns of table \"notification_setting\""
input notification_setting_stddev_order_by {
  account_id: order_by
  id: order_by
}

"order by stddev_pop() on columns of table \"notification_setting\""
input notification_setting_stddev_pop_order_by {
  account_id: order_by
  id: order_by
}

"order by stddev_samp() on columns of table \"notification_setting\""
input notification_setting_stddev_samp_order_by {
  account_id: order_by
  id: order_by
}

"order by sum() on columns of table \"notification_setting\""
input notification_setting_sum_order_by {
  account_id: order_by
  id: order_by
}

"order by var_pop() on columns of table \"notification_setting\""
input notification_setting_var_pop_order_by {
  account_id: order_by
  id: order_by
}

"order by var_samp() on columns of table \"notification_setting\""
input notification_setting_var_samp_order_by {
  account_id: order_by
  id: order_by
}

"order by variance() on columns of table \"notification_setting\""
input notification_setting_variance_order_by {
  account_id: order_by
  id: order_by
}

"expression to compare columns of type numeric. All fields are combined with logical 'AND'."
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"expression to compare columns of type privacy_enum. All fields are combined with logical 'AND'."
input privacy_enum_comparison_exp {
  _eq: privacy_enum
  _gt: privacy_enum
  _gte: privacy_enum
  _in: [privacy_enum!]
  _is_null: Boolean
  _lt: privacy_enum
  _lte: privacy_enum
  _neq: privacy_enum
  _nin: [privacy_enum!]
}

"order by aggregate values of table \"quotation\""
input quotation_aggregate_order_by {
  avg: quotation_avg_order_by
  count: order_by
  max: quotation_max_order_by
  min: quotation_min_order_by
  stddev: quotation_stddev_order_by
  stddev_pop: quotation_stddev_pop_order_by
  stddev_samp: quotation_stddev_samp_order_by
  sum: quotation_sum_order_by
  var_pop: quotation_var_pop_order_by
  var_samp: quotation_var_samp_order_by
  variance: quotation_variance_order_by
}

"input type for inserting array relation for remote table \"quotation\""
input quotation_arr_rel_insert_input {
  data: [quotation_insert_input!]!
  on_conflict: quotation_on_conflict
}

"order by avg() on columns of table \"quotation\""
input quotation_avg_order_by {
  fee_for_first_block: order_by
  fee_per_subsequent_block: order_by
  first_block_duration_m: order_by
  id: order_by
  subsequent_block_duration_m: order_by
}

"Boolean expression to filter rows from the table \"quotation\". All fields are combined with a logical 'AND'."
input quotation_bool_exp {
  _and: [quotation_bool_exp]
  _not: quotation_bool_exp
  _or: [quotation_bool_exp]
  created_at: timestamptz_comparison_exp
  fee_for_first_block: numeric_comparison_exp
  fee_per_subsequent_block: numeric_comparison_exp
  first_block_duration_m: Int_comparison_exp
  id: Int_comparison_exp
  requestor_type: String_comparison_exp
  subsequent_block_duration_m: Int_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"input type for incrementing integer column in table \"quotation\""
input quotation_inc_input {
  fee_for_first_block: numeric
  fee_per_subsequent_block: numeric
  first_block_duration_m: Int
  id: Int
  subsequent_block_duration_m: Int
}

"input type for inserting data into table \"quotation\""
input quotation_insert_input {
  created_at: timestamptz
  fee_for_first_block: numeric
  fee_per_subsequent_block: numeric
  first_block_duration_m: Int
  id: Int
  requestor_type: String
  subsequent_block_duration_m: Int
  updated_at: timestamptz
}

"order by max() on columns of table \"quotation\""
input quotation_max_order_by {
  created_at: order_by
  fee_for_first_block: order_by
  fee_per_subsequent_block: order_by
  first_block_duration_m: order_by
  id: order_by
  requestor_type: order_by
  subsequent_block_duration_m: order_by
  updated_at: order_by
}

"order by min() on columns of table \"quotation\""
input quotation_min_order_by {
  created_at: order_by
  fee_for_first_block: order_by
  fee_per_subsequent_block: order_by
  first_block_duration_m: order_by
  id: order_by
  requestor_type: order_by
  subsequent_block_duration_m: order_by
  updated_at: order_by
}

"input type for inserting object relation for remote table \"quotation\""
input quotation_obj_rel_insert_input {
  data: quotation_insert_input!
  on_conflict: quotation_on_conflict
}

"on conflict condition type for table \"quotation\""
input quotation_on_conflict {
  constraint: quotation_constraint!
  update_columns: [quotation_update_column!]!
  where: quotation_bool_exp
}

"ordering options when selecting data from \"quotation\""
input quotation_order_by {
  created_at: order_by
  fee_for_first_block: order_by
  fee_per_subsequent_block: order_by
  first_block_duration_m: order_by
  id: order_by
  requestor_type: order_by
  subsequent_block_duration_m: order_by
  updated_at: order_by
}

"primary key columns input for table: \"quotation\""
input quotation_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"quotation\""
input quotation_set_input {
  created_at: timestamptz
  fee_for_first_block: numeric
  fee_per_subsequent_block: numeric
  first_block_duration_m: Int
  id: Int
  requestor_type: String
  subsequent_block_duration_m: Int
  updated_at: timestamptz
}

"order by stddev() on columns of table \"quotation\""
input quotation_stddev_order_by {
  fee_for_first_block: order_by
  fee_per_subsequent_block: order_by
  first_block_duration_m: order_by
  id: order_by
  subsequent_block_duration_m: order_by
}

"order by stddev_pop() on columns of table \"quotation\""
input quotation_stddev_pop_order_by {
  fee_for_first_block: order_by
  fee_per_subsequent_block: order_by
  first_block_duration_m: order_by
  id: order_by
  subsequent_block_duration_m: order_by
}

"order by stddev_samp() on columns of table \"quotation\""
input quotation_stddev_samp_order_by {
  fee_for_first_block: order_by
  fee_per_subsequent_block: order_by
  first_block_duration_m: order_by
  id: order_by
  subsequent_block_duration_m: order_by
}

"order by sum() on columns of table \"quotation\""
input quotation_sum_order_by {
  fee_for_first_block: order_by
  fee_per_subsequent_block: order_by
  first_block_duration_m: order_by
  id: order_by
  subsequent_block_duration_m: order_by
}

"order by var_pop() on columns of table \"quotation\""
input quotation_var_pop_order_by {
  fee_for_first_block: order_by
  fee_per_subsequent_block: order_by
  first_block_duration_m: order_by
  id: order_by
  subsequent_block_duration_m: order_by
}

"order by var_samp() on columns of table \"quotation\""
input quotation_var_samp_order_by {
  fee_for_first_block: order_by
  fee_per_subsequent_block: order_by
  first_block_duration_m: order_by
  id: order_by
  subsequent_block_duration_m: order_by
}

"order by variance() on columns of table \"quotation\""
input quotation_variance_order_by {
  fee_for_first_block: order_by
  fee_per_subsequent_block: order_by
  first_block_duration_m: order_by
  id: order_by
  subsequent_block_duration_m: order_by
}

"expression to compare columns of type rating_enum. All fields are combined with logical 'AND'."
input rating_enum_comparison_exp {
  _eq: rating_enum
  _gt: rating_enum
  _gte: rating_enum
  _in: [rating_enum!]
  _is_null: Boolean
  _lt: rating_enum
  _lte: rating_enum
  _neq: rating_enum
  _nin: [rating_enum!]
}

"order by aggregate values of table \"service_requestor\""
input service_requestor_aggregate_order_by {
  avg: service_requestor_avg_order_by
  count: order_by
  max: service_requestor_max_order_by
  min: service_requestor_min_order_by
  stddev: service_requestor_stddev_order_by
  stddev_pop: service_requestor_stddev_pop_order_by
  stddev_samp: service_requestor_stddev_samp_order_by
  sum: service_requestor_sum_order_by
  var_pop: service_requestor_var_pop_order_by
  var_samp: service_requestor_var_samp_order_by
  variance: service_requestor_variance_order_by
}

"input type for inserting array relation for remote table \"service_requestor\""
input service_requestor_arr_rel_insert_input {
  data: [service_requestor_insert_input!]!
  on_conflict: service_requestor_on_conflict
}

"order by avg() on columns of table \"service_requestor\""
input service_requestor_avg_order_by {
  account_id: order_by
  id: order_by
  membership_id: order_by
}

"Boolean expression to filter rows from the table \"service_requestor\". All fields are combined with a logical 'AND'."
input service_requestor_bool_exp {
  _and: [service_requestor_bool_exp]
  _not: service_requestor_bool_exp
  _or: [service_requestor_bool_exp]
  account: account_bool_exp
  account_id: Int_comparison_exp
  clients: client_bool_exp
  id: Int_comparison_exp
  membership: membership_bool_exp
  membership_id: Int_comparison_exp
  organisation: String_comparison_exp
}

"input type for incrementing integer column in table \"service_requestor\""
input service_requestor_inc_input {
  account_id: Int
  id: Int
  membership_id: Int
}

"input type for inserting data into table \"service_requestor\""
input service_requestor_insert_input {
  account: account_obj_rel_insert_input
  account_id: Int
  clients: client_arr_rel_insert_input
  id: Int
  membership: membership_obj_rel_insert_input
  membership_id: Int
  organisation: String
}

"order by max() on columns of table \"service_requestor\""
input service_requestor_max_order_by {
  account_id: order_by
  id: order_by
  membership_id: order_by
  organisation: order_by
}

"order by min() on columns of table \"service_requestor\""
input service_requestor_min_order_by {
  account_id: order_by
  id: order_by
  membership_id: order_by
  organisation: order_by
}

"input type for inserting object relation for remote table \"service_requestor\""
input service_requestor_obj_rel_insert_input {
  data: service_requestor_insert_input!
  on_conflict: service_requestor_on_conflict
}

"on conflict condition type for table \"service_requestor\""
input service_requestor_on_conflict {
  constraint: service_requestor_constraint!
  update_columns: [service_requestor_update_column!]!
  where: service_requestor_bool_exp
}

"ordering options when selecting data from \"service_requestor\""
input service_requestor_order_by {
  account: account_order_by
  account_id: order_by
  clients_aggregate: client_aggregate_order_by
  id: order_by
  membership: membership_order_by
  membership_id: order_by
  organisation: order_by
}

"primary key columns input for table: \"service_requestor\""
input service_requestor_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"service_requestor\""
input service_requestor_set_input {
  account_id: Int
  id: Int
  membership_id: Int
  organisation: String
}

"order by stddev() on columns of table \"service_requestor\""
input service_requestor_stddev_order_by {
  account_id: order_by
  id: order_by
  membership_id: order_by
}

"order by stddev_pop() on columns of table \"service_requestor\""
input service_requestor_stddev_pop_order_by {
  account_id: order_by
  id: order_by
  membership_id: order_by
}

"order by stddev_samp() on columns of table \"service_requestor\""
input service_requestor_stddev_samp_order_by {
  account_id: order_by
  id: order_by
  membership_id: order_by
}

"order by sum() on columns of table \"service_requestor\""
input service_requestor_sum_order_by {
  account_id: order_by
  id: order_by
  membership_id: order_by
}

"order by var_pop() on columns of table \"service_requestor\""
input service_requestor_var_pop_order_by {
  account_id: order_by
  id: order_by
  membership_id: order_by
}

"order by var_samp() on columns of table \"service_requestor\""
input service_requestor_var_samp_order_by {
  account_id: order_by
  id: order_by
  membership_id: order_by
}

"order by variance() on columns of table \"service_requestor\""
input service_requestor_variance_order_by {
  account_id: order_by
  id: order_by
  membership_id: order_by
}

"order by aggregate values of table \"telegram_information\""
input telegram_information_aggregate_order_by {
  avg: telegram_information_avg_order_by
  count: order_by
  max: telegram_information_max_order_by
  min: telegram_information_min_order_by
  stddev: telegram_information_stddev_order_by
  stddev_pop: telegram_information_stddev_pop_order_by
  stddev_samp: telegram_information_stddev_samp_order_by
  sum: telegram_information_sum_order_by
  var_pop: telegram_information_var_pop_order_by
  var_samp: telegram_information_var_samp_order_by
  variance: telegram_information_variance_order_by
}

"input type for inserting array relation for remote table \"telegram_information\""
input telegram_information_arr_rel_insert_input {
  data: [telegram_information_insert_input!]!
  on_conflict: telegram_information_on_conflict
}

"order by avg() on columns of table \"telegram_information\""
input telegram_information_avg_order_by {
  chat_id: order_by
  id: order_by
  notification_setting_id: order_by
}

"Boolean expression to filter rows from the table \"telegram_information\". All fields are combined with a logical 'AND'."
input telegram_information_bool_exp {
  _and: [telegram_information_bool_exp]
  _not: telegram_information_bool_exp
  _or: [telegram_information_bool_exp]
  chat_id: bigint_comparison_exp
  id: Int_comparison_exp
  notification_setting: notification_setting_bool_exp
  notification_setting_id: Int_comparison_exp
  user_handle: String_comparison_exp
}

"input type for incrementing integer column in table \"telegram_information\""
input telegram_information_inc_input {
  chat_id: bigint
  id: Int
  notification_setting_id: Int
}

"input type for inserting data into table \"telegram_information\""
input telegram_information_insert_input {
  chat_id: bigint
  id: Int
  notification_setting: notification_setting_obj_rel_insert_input
  notification_setting_id: Int
  user_handle: String
}

"order by max() on columns of table \"telegram_information\""
input telegram_information_max_order_by {
  chat_id: order_by
  id: order_by
  notification_setting_id: order_by
  user_handle: order_by
}

"order by min() on columns of table \"telegram_information\""
input telegram_information_min_order_by {
  chat_id: order_by
  id: order_by
  notification_setting_id: order_by
  user_handle: order_by
}

"input type for inserting object relation for remote table \"telegram_information\""
input telegram_information_obj_rel_insert_input {
  data: telegram_information_insert_input!
  on_conflict: telegram_information_on_conflict
}

"on conflict condition type for table \"telegram_information\""
input telegram_information_on_conflict {
  constraint: telegram_information_constraint!
  update_columns: [telegram_information_update_column!]!
  where: telegram_information_bool_exp
}

"ordering options when selecting data from \"telegram_information\""
input telegram_information_order_by {
  chat_id: order_by
  id: order_by
  notification_setting: notification_setting_order_by
  notification_setting_id: order_by
  user_handle: order_by
}

"primary key columns input for table: \"telegram_information\""
input telegram_information_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"telegram_information\""
input telegram_information_set_input {
  chat_id: bigint
  id: Int
  notification_setting_id: Int
  user_handle: String
}

"order by stddev() on columns of table \"telegram_information\""
input telegram_information_stddev_order_by {
  chat_id: order_by
  id: order_by
  notification_setting_id: order_by
}

"order by stddev_pop() on columns of table \"telegram_information\""
input telegram_information_stddev_pop_order_by {
  chat_id: order_by
  id: order_by
  notification_setting_id: order_by
}

"order by stddev_samp() on columns of table \"telegram_information\""
input telegram_information_stddev_samp_order_by {
  chat_id: order_by
  id: order_by
  notification_setting_id: order_by
}

"order by sum() on columns of table \"telegram_information\""
input telegram_information_sum_order_by {
  chat_id: order_by
  id: order_by
  notification_setting_id: order_by
}

"order by var_pop() on columns of table \"telegram_information\""
input telegram_information_var_pop_order_by {
  chat_id: order_by
  id: order_by
  notification_setting_id: order_by
}

"order by var_samp() on columns of table \"telegram_information\""
input telegram_information_var_samp_order_by {
  chat_id: order_by
  id: order_by
  notification_setting_id: order_by
}

"order by variance() on columns of table \"telegram_information\""
input telegram_information_variance_order_by {
  chat_id: order_by
  id: order_by
  notification_setting_id: order_by
}

"expression to compare columns of type timestamp. All fields are combined with logical 'AND'."
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

"expression to compare columns of type timestamptz. All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"order by aggregate values of table \"volunteer\""
input volunteer_aggregate_order_by {
  avg: volunteer_avg_order_by
  count: order_by
  max: volunteer_max_order_by
  min: volunteer_min_order_by
  stddev: volunteer_stddev_order_by
  stddev_pop: volunteer_stddev_pop_order_by
  stddev_samp: volunteer_stddev_samp_order_by
  sum: volunteer_sum_order_by
  var_pop: volunteer_var_pop_order_by
  var_samp: volunteer_var_samp_order_by
  variance: volunteer_variance_order_by
}

"input type for inserting array relation for remote table \"volunteer\""
input volunteer_arr_rel_insert_input {
  data: [volunteer_insert_input!]!
  on_conflict: volunteer_on_conflict
}

"order by aggregate values of table \"volunteer_assignment_opt_in\""
input volunteer_assignment_opt_in_aggregate_order_by {
  avg: volunteer_assignment_opt_in_avg_order_by
  count: order_by
  max: volunteer_assignment_opt_in_max_order_by
  min: volunteer_assignment_opt_in_min_order_by
  stddev: volunteer_assignment_opt_in_stddev_order_by
  stddev_pop: volunteer_assignment_opt_in_stddev_pop_order_by
  stddev_samp: volunteer_assignment_opt_in_stddev_samp_order_by
  sum: volunteer_assignment_opt_in_sum_order_by
  var_pop: volunteer_assignment_opt_in_var_pop_order_by
  var_samp: volunteer_assignment_opt_in_var_samp_order_by
  variance: volunteer_assignment_opt_in_variance_order_by
}

"input type for inserting array relation for remote table \"volunteer_assignment_opt_in\""
input volunteer_assignment_opt_in_arr_rel_insert_input {
  data: [volunteer_assignment_opt_in_insert_input!]!
  on_conflict: volunteer_assignment_opt_in_on_conflict
}

"order by avg() on columns of table \"volunteer_assignment_opt_in\""
input volunteer_assignment_opt_in_avg_order_by {
  assignment_id: order_by
  id: order_by
  volunteer_id: order_by
}

"Boolean expression to filter rows from the table \"volunteer_assignment_opt_in\". All fields are combined with a logical 'AND'."
input volunteer_assignment_opt_in_bool_exp {
  _and: [volunteer_assignment_opt_in_bool_exp]
  _not: volunteer_assignment_opt_in_bool_exp
  _or: [volunteer_assignment_opt_in_bool_exp]
  assignment: assignment_bool_exp
  assignment_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  id: Int_comparison_exp
  status: String_comparison_exp
  volunteer: volunteer_bool_exp
  volunteer_id: Int_comparison_exp
}

"input type for incrementing integer column in table \"volunteer_assignment_opt_in\""
input volunteer_assignment_opt_in_inc_input {
  assignment_id: Int
  id: Int
  volunteer_id: Int
}

"input type for inserting data into table \"volunteer_assignment_opt_in\""
input volunteer_assignment_opt_in_insert_input {
  assignment: assignment_obj_rel_insert_input
  assignment_id: Int
  created_at: timestamptz
  id: Int
  status: String
  volunteer: volunteer_obj_rel_insert_input
  volunteer_id: Int
}

"order by max() on columns of table \"volunteer_assignment_opt_in\""
input volunteer_assignment_opt_in_max_order_by {
  assignment_id: order_by
  created_at: order_by
  id: order_by
  status: order_by
  volunteer_id: order_by
}

"order by min() on columns of table \"volunteer_assignment_opt_in\""
input volunteer_assignment_opt_in_min_order_by {
  assignment_id: order_by
  created_at: order_by
  id: order_by
  status: order_by
  volunteer_id: order_by
}

"input type for inserting object relation for remote table \"volunteer_assignment_opt_in\""
input volunteer_assignment_opt_in_obj_rel_insert_input {
  data: volunteer_assignment_opt_in_insert_input!
  on_conflict: volunteer_assignment_opt_in_on_conflict
}

"on conflict condition type for table \"volunteer_assignment_opt_in\""
input volunteer_assignment_opt_in_on_conflict {
  constraint: volunteer_assignment_opt_in_constraint!
  update_columns: [volunteer_assignment_opt_in_update_column!]!
  where: volunteer_assignment_opt_in_bool_exp
}

"ordering options when selecting data from \"volunteer_assignment_opt_in\""
input volunteer_assignment_opt_in_order_by {
  assignment: assignment_order_by
  assignment_id: order_by
  created_at: order_by
  id: order_by
  status: order_by
  volunteer: volunteer_order_by
  volunteer_id: order_by
}

"primary key columns input for table: \"volunteer_assignment_opt_in\""
input volunteer_assignment_opt_in_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"volunteer_assignment_opt_in\""
input volunteer_assignment_opt_in_set_input {
  assignment_id: Int
  created_at: timestamptz
  id: Int
  status: String
  volunteer_id: Int
}

"order by stddev() on columns of table \"volunteer_assignment_opt_in\""
input volunteer_assignment_opt_in_stddev_order_by {
  assignment_id: order_by
  id: order_by
  volunteer_id: order_by
}

"order by stddev_pop() on columns of table \"volunteer_assignment_opt_in\""
input volunteer_assignment_opt_in_stddev_pop_order_by {
  assignment_id: order_by
  id: order_by
  volunteer_id: order_by
}

"order by stddev_samp() on columns of table \"volunteer_assignment_opt_in\""
input volunteer_assignment_opt_in_stddev_samp_order_by {
  assignment_id: order_by
  id: order_by
  volunteer_id: order_by
}

"order by sum() on columns of table \"volunteer_assignment_opt_in\""
input volunteer_assignment_opt_in_sum_order_by {
  assignment_id: order_by
  id: order_by
  volunteer_id: order_by
}

"order by var_pop() on columns of table \"volunteer_assignment_opt_in\""
input volunteer_assignment_opt_in_var_pop_order_by {
  assignment_id: order_by
  id: order_by
  volunteer_id: order_by
}

"order by var_samp() on columns of table \"volunteer_assignment_opt_in\""
input volunteer_assignment_opt_in_var_samp_order_by {
  assignment_id: order_by
  id: order_by
  volunteer_id: order_by
}

"order by variance() on columns of table \"volunteer_assignment_opt_in\""
input volunteer_assignment_opt_in_variance_order_by {
  assignment_id: order_by
  id: order_by
  volunteer_id: order_by
}

"order by avg() on columns of table \"volunteer\""
input volunteer_avg_order_by {
  account_id: order_by
  id: order_by
}

"Boolean expression to filter rows from the table \"volunteer\". All fields are combined with a logical 'AND'."
input volunteer_bool_exp {
  _and: [volunteer_bool_exp]
  _not: volunteer_bool_exp
  _or: [volunteer_bool_exp]
  account: account_bool_exp
  account_id: Int_comparison_exp
  approval_status: Boolean_comparison_exp
  assignments: assignment_bool_exp
  blacklists: blacklist_bool_exp
  feedbacks: feedback_bool_exp
  id: Int_comparison_exp
  interpreter: Boolean_comparison_exp
  notetaker: Boolean_comparison_exp
  volunteer_assignment_opt_ins: volunteer_assignment_opt_in_bool_exp
}

"input type for incrementing integer column in table \"volunteer\""
input volunteer_inc_input {
  account_id: Int
  id: Int
}

"input type for inserting data into table \"volunteer\""
input volunteer_insert_input {
  account: account_obj_rel_insert_input
  account_id: Int
  approval_status: Boolean
  assignments: assignment_arr_rel_insert_input
  blacklists: blacklist_arr_rel_insert_input
  feedbacks: feedback_arr_rel_insert_input
  id: Int
  interpreter: Boolean
  notetaker: Boolean
  volunteer_assignment_opt_ins: volunteer_assignment_opt_in_arr_rel_insert_input
}

"order by max() on columns of table \"volunteer\""
input volunteer_max_order_by {
  account_id: order_by
  id: order_by
}

"order by min() on columns of table \"volunteer\""
input volunteer_min_order_by {
  account_id: order_by
  id: order_by
}

"input type for inserting object relation for remote table \"volunteer\""
input volunteer_obj_rel_insert_input {
  data: volunteer_insert_input!
  on_conflict: volunteer_on_conflict
}

"on conflict condition type for table \"volunteer\""
input volunteer_on_conflict {
  constraint: volunteer_constraint!
  update_columns: [volunteer_update_column!]!
  where: volunteer_bool_exp
}

"ordering options when selecting data from \"volunteer\""
input volunteer_order_by {
  account: account_order_by
  account_id: order_by
  approval_status: order_by
  assignments_aggregate: assignment_aggregate_order_by
  blacklists_aggregate: blacklist_aggregate_order_by
  feedbacks_aggregate: feedback_aggregate_order_by
  id: order_by
  interpreter: order_by
  notetaker: order_by
  volunteer_assignment_opt_ins_aggregate: volunteer_assignment_opt_in_aggregate_order_by
}

"primary key columns input for table: \"volunteer\""
input volunteer_pk_columns_input {
  id: Int!
}

"input type for updating data in table \"volunteer\""
input volunteer_set_input {
  account_id: Int
  approval_status: Boolean
  id: Int
  interpreter: Boolean
  notetaker: Boolean
}

"order by stddev() on columns of table \"volunteer\""
input volunteer_stddev_order_by {
  account_id: order_by
  id: order_by
}

"order by stddev_pop() on columns of table \"volunteer\""
input volunteer_stddev_pop_order_by {
  account_id: order_by
  id: order_by
}

"order by stddev_samp() on columns of table \"volunteer\""
input volunteer_stddev_samp_order_by {
  account_id: order_by
  id: order_by
}

"order by sum() on columns of table \"volunteer\""
input volunteer_sum_order_by {
  account_id: order_by
  id: order_by
}

"order by var_pop() on columns of table \"volunteer\""
input volunteer_var_pop_order_by {
  account_id: order_by
  id: order_by
}

"order by var_samp() on columns of table \"volunteer\""
input volunteer_var_samp_order_by {
  account_id: order_by
  id: order_by
}

"order by variance() on columns of table \"volunteer\""
input volunteer_variance_order_by {
  account_id: order_by
  id: order_by
}

scalar bigint

scalar float8

scalar numeric

scalar privacy_enum

scalar rating_enum

scalar timestamp

scalar timestamptz
